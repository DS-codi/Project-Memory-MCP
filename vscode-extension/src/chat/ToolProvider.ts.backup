/**
 * Tool Provider - Language Model Tools for Copilot Chat
 * 
 * Registers tools that Copilot can autonomously invoke during conversations
 * to interact with the Project Memory MCP server.
 */

import * as vscode from 'vscode';
import { McpBridge } from './McpBridge';

/**
 * Tool invocation result
 */
interface ToolResult {
    success: boolean;
    data?: unknown;
    error?: string;
}

/**
 * Plan state structure
 */
interface PlanState {
    plan_id: string;
    title: string;
    description?: string;
    category?: string;
    priority?: string;
    status?: string;
    steps?: Array<{
        phase: string;
        task: string;
        status: string;
    }>;
}

/**
 * Workspace context structure
 */
interface WorkspaceContext {
    workspace_id: string;
    workspace_path: string;
    codebase_profile?: {
        languages?: string[];
        frameworks?: string[];
        file_count?: number;
        dependencies?: Record<string, string>;
    };
}

/**
 * Tool Provider class that registers Language Model Tools
 */
export class ToolProvider implements vscode.Disposable {
    private mcpBridge: McpBridge;
    private workspaceId: string | null = null;
    private disposables: vscode.Disposable[] = [];

    constructor(mcpBridge: McpBridge) {
        this.mcpBridge = mcpBridge;
        this.registerTools();
    }

    /**
     * Register all language model tools
     */
    private registerTools(): void {
        // memory_getPlanState
        this.disposables.push(
            vscode.lm.registerTool('memory_getPlanState', {
                invoke: async (options, token) => {
                    return await this.handleGetPlanState(
                        options as vscode.LanguageModelToolInvocationOptions<{ planId: string }>,
                        token
                    );
                }
            })
        );

        // memory_updateStep
        this.disposables.push(
            vscode.lm.registerTool('memory_updateStep', {
                invoke: async (options, token) => {
                    return await this.handleUpdateStep(
                        options as vscode.LanguageModelToolInvocationOptions<{ planId: string; stepIndex: number; status: string }>,
                        token
                    );
                }
            })
        );

        // memory_createPlan
        this.disposables.push(
            vscode.lm.registerTool('memory_createPlan', {
                invoke: async (options, token) => {
                    return await this.handleCreatePlan(
                        options as vscode.LanguageModelToolInvocationOptions<{ title: string; description: string; category: string }>,
                        token
                    );
                }
            })
        );

        // memory_getWorkspaceContext
        this.disposables.push(
            vscode.lm.registerTool('memory_getWorkspaceContext', {
                invoke: async (options, token) => {
                    return await this.handleGetWorkspaceContext(
                        options as vscode.LanguageModelToolInvocationOptions<Record<string, never>>,
                        token
                    );
                }
            })
        );

        // memory_listPlans - List all plans in the workspace
        this.disposables.push(
            vscode.lm.registerTool('memory_listPlans', {
                invoke: async (options, token) => {
                    return await this.handleListPlans(
                        options as vscode.LanguageModelToolInvocationOptions<{ includeArchived?: boolean }>,
                        token
                    );
                }
            })
        );

        // memory_handoff
        this.disposables.push(
            vscode.lm.registerTool('memory_handoff', {
                invoke: async (options, token) => {
                    return await this.handleHandoff(
                        options as vscode.LanguageModelToolInvocationOptions<{ planId: string; targetAgent: string; summary: string }>,
                        token
                    );
                }
            })
        );

        // memory_addNote
        this.disposables.push(
            vscode.lm.registerTool('memory_addNote', {
                invoke: async (options, token) => {
                    return await this.handleAddNote(
                        options as vscode.LanguageModelToolInvocationOptions<{ planId: string; note: string; type?: string }>,
                        token
                    );
                }
            })
        );
    }

    /**
     * Ensure workspace is registered
     */
    private async ensureWorkspace(): Promise<string> {
        if (this.workspaceId) {
            return this.workspaceId;
        }

        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            throw new Error('No workspace folder open');
        }

        const result = await this.mcpBridge.callTool<{ workspace_id: string }>(
            'register_workspace',
            { workspace_path: workspaceFolder.uri.fsPath }
        );

        this.workspaceId = result.workspace_id;
        return this.workspaceId;
    }

    /**
     * Handle memory_getPlanState tool invocation
     */
    private async handleGetPlanState(
        options: vscode.LanguageModelToolInvocationOptions<{ planId: string }>,
        token: vscode.CancellationToken
    ): Promise<vscode.LanguageModelToolResult> {
        try {
            if (!this.mcpBridge.isConnected()) {
                return this.errorResult('MCP server not connected');
            }

            const workspaceId = await this.ensureWorkspace();
            const { planId } = options.input;

            if (!planId) {
                return this.errorResult('planId is required');
            }

            const result = await this.mcpBridge.callTool<PlanState>(
                'get_plan_state',
                {
                    workspace_id: workspaceId,
                    plan_id: planId
                }
            );

            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(JSON.stringify(result, null, 2))
            ]);
        } catch (error) {
            return this.errorResult(error);
        }
    }

    /**
     * Handle memory_listPlans tool invocation
     */
    private async handleListPlans(
        options: vscode.LanguageModelToolInvocationOptions<{ includeArchived?: boolean }>,
        token: vscode.CancellationToken
    ): Promise<vscode.LanguageModelToolResult> {
        try {
            if (!this.mcpBridge.isConnected()) {
                return this.errorResult('MCP server not connected');
            }

            const workspaceId = await this.ensureWorkspace();
            const includeArchived = options.input?.includeArchived ?? false;

            const result = await this.mcpBridge.callTool<{
                active_plans: Array<{
                    plan_id: string;
                    title: string;
                    status?: string;
                    category?: string;
                    priority?: string;
                    created_at?: string;
                }>;
                archived_plans?: string[];
                total: number;
            }>(
                'list_plans',
                {
                    workspace_id: workspaceId,
                    include_archived: includeArchived
                }
            );

            const plans = result.active_plans || [];
            
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(JSON.stringify({
                    workspace_id: workspaceId,
                    plans: plans,
                    total: plans.length,
                    archived_count: result.archived_plans?.length || 0,
                    message: plans.length > 0 
                        ? `Found ${plans.length} plan(s) in this workspace`
                        : 'No plans found in this workspace'
                }, null, 2))
            ]);
        } catch (error) {
            return this.errorResult(error);
        }
    }

    /**
     * Handle memory_updateStep tool invocation
     */
    private async handleUpdateStep(
        options: vscode.LanguageModelToolInvocationOptions<{ 
            planId: string;
            stepIndex: number;
            status: string;
        }>,
        token: vscode.CancellationToken
    ): Promise<vscode.LanguageModelToolResult> {
        try {
            if (!this.mcpBridge.isConnected()) {
                return this.errorResult('MCP server not connected');
            }

            const workspaceId = await this.ensureWorkspace();
            const { planId, stepIndex, status } = options.input;

            if (!planId || stepIndex === undefined || !status) {
                return this.errorResult('planId, stepIndex, and status are required');
            }

            // Validate status
            const validStatuses = ['pending', 'active', 'done', 'blocked'];
            if (!validStatuses.includes(status)) {
                return this.errorResult(`Invalid status. Must be one of: ${validStatuses.join(', ')}`);
            }

            const result = await this.mcpBridge.callTool(
                'update_step',
                {
                    workspace_id: workspaceId,
                    plan_id: planId,
                    step_index: stepIndex,
                    status
                }
            );

            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(JSON.stringify({
                    success: true,
                    message: `Step ${stepIndex} updated to ${status}`,
                    result
                }, null, 2))
            ]);
        } catch (error) {
            return this.errorResult(error);
        }
    }

    /**
     * Handle memory_createPlan tool invocation
     */
    private async handleCreatePlan(
        options: vscode.LanguageModelToolInvocationOptions<{
            title: string;
            description: string;
            category: string;
        }>,
        token: vscode.CancellationToken
    ): Promise<vscode.LanguageModelToolResult> {
        try {
            if (!this.mcpBridge.isConnected()) {
                return this.errorResult('MCP server not connected');
            }

            const workspaceId = await this.ensureWorkspace();
            const { title, description, category } = options.input;

            if (!title || !description || !category) {
                return this.errorResult('title, description, and category are required');
            }

            // Validate category
            const validCategories = ['feature', 'bug', 'change', 'analysis', 'debug', 'refactor', 'documentation'];
            if (!validCategories.includes(category)) {
                return this.errorResult(`Invalid category. Must be one of: ${validCategories.join(', ')}`);
            }

            const result = await this.mcpBridge.callTool<PlanState>(
                'create_plan',
                {
                    workspace_id: workspaceId,
                    title,
                    description,
                    category
                }
            );

            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(JSON.stringify({
                    success: true,
                    plan_id: result.plan_id,
                    title: result.title,
                    message: 'Plan created successfully'
                }, null, 2))
            ]);
        } catch (error) {
            return this.errorResult(error);
        }
    }

    /**
     * Handle memory_getWorkspaceContext tool invocation
     */
    private async handleGetWorkspaceContext(
        options: vscode.LanguageModelToolInvocationOptions<Record<string, never>>,
        token: vscode.CancellationToken
    ): Promise<vscode.LanguageModelToolResult> {
        try {
            if (!this.mcpBridge.isConnected()) {
                return this.errorResult('MCP server not connected');
            }

            const workspaceId = await this.ensureWorkspace();

            // Try to get workspace info
            let context: WorkspaceContext;
            try {
                context = await this.mcpBridge.callTool<WorkspaceContext>(
                    'get_workspace_info',
                    { workspace_id: workspaceId }
                );
            } catch {
                // Fall back to basic info
                const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
                context = {
                    workspace_id: workspaceId,
                    workspace_path: workspaceFolder?.uri.fsPath || 'unknown'
                };
            }

            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(JSON.stringify(context, null, 2))
            ]);
        } catch (error) {
            return this.errorResult(error);
        }
    }

    /**
     * Handle memory_handoff tool invocation
     */
    private async handleHandoff(
        options: vscode.LanguageModelToolInvocationOptions<{
            planId: string;
            targetAgent: string;
            summary: string;
        }>,
        token: vscode.CancellationToken
    ): Promise<vscode.LanguageModelToolResult> {
        try {
            if (!this.mcpBridge.isConnected()) {
                return this.errorResult('MCP server not connected');
            }

            const workspaceId = await this.ensureWorkspace();
            const { planId, targetAgent, summary } = options.input;

            if (!planId || !targetAgent || !summary) {
                return this.errorResult('planId, targetAgent, and summary are required');
            }

            // Validate agent type
            const validAgents = ['Coordinator', 'Researcher', 'Architect', 'Executor', 'Revisionist', 'Reviewer', 'Tester', 'Archivist'];
            if (!validAgents.includes(targetAgent)) {
                return this.errorResult(`Invalid agent type. Must be one of: ${validAgents.join(', ')}`);
            }

            const result = await this.mcpBridge.callTool(
                'handoff',
                {
                    workspace_id: workspaceId,
                    plan_id: planId,
                    target_agent: targetAgent,
                    summary
                }
            );

            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(JSON.stringify({
                    success: true,
                    message: `Handoff to ${targetAgent} completed`,
                    result
                }, null, 2))
            ]);
        } catch (error) {
            return this.errorResult(error);
        }
    }

    /**
     * Handle memory_addNote tool invocation
     */
    private async handleAddNote(
        options: vscode.LanguageModelToolInvocationOptions<{
            planId: string;
            note: string;
            type?: string;
        }>,
        token: vscode.CancellationToken
    ): Promise<vscode.LanguageModelToolResult> {
        try {
            if (!this.mcpBridge.isConnected()) {
                return this.errorResult('MCP server not connected');
            }

            const workspaceId = await this.ensureWorkspace();
            const { planId, note, type = 'info' } = options.input;

            if (!planId || !note) {
                return this.errorResult('planId and note are required');
            }

            // Validate note type
            const validTypes = ['info', 'warning', 'instruction'];
            if (!validTypes.includes(type)) {
                return this.errorResult(`Invalid note type. Must be one of: ${validTypes.join(', ')}`);
            }

            const result = await this.mcpBridge.callTool(
                'add_plan_note',
                {
                    workspace_id: workspaceId,
                    plan_id: planId,
                    note,
                    type
                }
            );

            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(JSON.stringify({
                    success: true,
                    message: 'Note added to plan',
                    result
                }, null, 2))
            ]);
        } catch (error) {
            return this.errorResult(error);
        }
    }

    /**
     * Create an error result
     */
    private errorResult(error: unknown): vscode.LanguageModelToolResult {
        const message = error instanceof Error ? error.message : String(error);
        return new vscode.LanguageModelToolResult([
            new vscode.LanguageModelTextPart(JSON.stringify({
                success: false,
                error: message
            }, null, 2))
        ]);
    }

    /**
     * Reset workspace ID (useful when workspace changes)
     */
    resetWorkspace(): void {
        this.workspaceId = null;
    }

    /**
     * Dispose of resources
     */
    dispose(): void {
        for (const disposable of this.disposables) {
            disposable.dispose();
        }
        this.disposables = [];
    }
}
