# Plan 3.5: Plan Type Schema Extension & Migration Reference

**Category:** Feature  
**Priority:** Critical  
**Status:** Partially Complete  
**Parent Program:** [Database Migration & System Stabilization](00-program-overview.md)  
**Dependencies:** Plan 3 (Schema Design & DB Foundation)  
**Blocks:** Plan 4 (Data Migration) — Plan 4 must not start until this plan completes  
**Workspace Directory:** `C:\Users\User\Project_Memory_MCP\Project-Memory-MCP`

## Goal

Plan 3 establishes the DB scaffold. This plan completes it by:

1. Writing the precise DDL for all plan-type-variant fields on `plans`, `programs`, `program_plans`, `program_risks`, and `dependencies` — including CHECK constraints, exact column names, and JSON column semantics
2. Updating the DB row types (`types.ts`) and data access layer to be type-aware
3. Implementing category normalization in `mappers.ts`
4. Annotating Plan 4's migration steps with the exact column names they must populate
5. Producing comprehensive schema reference documentation

Plan 3 is agnostic about which values `category` stores or how paused/program plans differ. This plan removes that ambiguity everywhere it matters — before migration code is written.

---

## Phase 1: Plans Table — Full Column Specification

- [x] **1.1** Update `server/src/db/migrations/001-initial-schema.sql` to replace the `plans` table skeleton with the full column spec:

  ```sql
  CREATE TABLE plans (
    id                    TEXT PRIMARY KEY,
    workspace_id          TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    program_id            TEXT REFERENCES programs(id) ON DELETE SET NULL,
    title                 TEXT NOT NULL,
    description           TEXT NOT NULL DEFAULT '',
    category              TEXT NOT NULL DEFAULT 'feature'
                            CHECK(category IN (
                              'feature','bugfix','refactor',
                              'orchestration','quick_task','advisory'
                            )),
    priority              TEXT NOT NULL DEFAULT 'medium'
                            CHECK(priority IN ('low','medium','high','critical')),
    status                TEXT NOT NULL DEFAULT 'active'
                            CHECK(status IN (
                              'active','completed','archived','paused','blocked'
                            )),
    schema_version        TEXT NOT NULL DEFAULT '2.0',
    goals                 TEXT NOT NULL DEFAULT '[]',            -- JSON: string[]
    success_criteria      TEXT NOT NULL DEFAULT '[]',            -- JSON: string[]
    categorization        TEXT,         -- JSON: CategorizationResult | null
    deployment_context    TEXT,         -- JSON: DeploymentContext | null
    confirmation_state    TEXT,         -- JSON: ConfirmationState | null
    paused_at             TEXT,         -- ISO 8601 timestamp | null
    paused_at_snapshot    TEXT,         -- JSON: PausedAtSnapshot | null
    recommended_next_agent TEXT,
    created_at            TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at            TEXT NOT NULL DEFAULT (datetime('now')),
    archived_at           TEXT,
    completed_at          TEXT
  );
  ```

  **Column semantics:**

  | Column | Source in `state.json` | Notes |
  |--------|------------------------|-------|
  | `id` | `plan_id` | `plan_` prefixed UUID |
  | `workspace_id` | Inferred from directory path | FK, required |
  | `program_id` | `state.json.program_id` | Nullable FK — set for child plans |
  | `category` | `state.json.category` | Apply `migrateCategoryToV2()` for v1 plans; default `'feature'` if absent |
  | `priority` | `state.json.priority` | Default `'medium'` if absent |
  | `status` | `state.json.status` | Default `'active'` if absent |
  | `schema_version` | Always `'2.0'` | All plans normalized to v2 in DB regardless of source |
  | `goals` | `state.json.goals ?? []` | Serialized as JSON string |
  | `success_criteria` | `state.json.success_criteria ?? []` | Serialized as JSON string |
  | `categorization` | `state.json.categorization` | Full `{category, confidence, reasoning, suggested_workflow, skip_agents}` |
  | `deployment_context` | `state.json.deployment_context` | `{deployed_by, reason, override_validation}` |
  | `confirmation_state` | `state.json.confirmation_state` | Approval gate state |
  | `paused_at` | `state.json.paused_at_snapshot?.paused_at` | Extracted for indexed queries |
  | `paused_at_snapshot` | `state.json.paused_at_snapshot` | Full snapshot JSON: `{session_id, step_index, reason, user_notes, paused_at}` |
  | `recommended_next_agent` | `state.json.recommended_next_agent` | Last handoff recommendation |
  | `archived_at` | Not in state.json | Set by `archivePlan()` call, not during import |
  | `completed_at` | `state.json.completed_at` | Null for in-progress plans |

- [x] **1.2** Add indexes on the new columns:

  ```sql
  CREATE INDEX idx_plans_workspace_category  ON plans(workspace_id, category);
  CREATE INDEX idx_plans_workspace_status    ON plans(workspace_id, status);
  CREATE INDEX idx_plans_program_id          ON plans(program_id) WHERE program_id IS NOT NULL;
  CREATE INDEX idx_plans_paused_at           ON plans(paused_at) WHERE paused_at IS NOT NULL;
  ```

- [x] **1.3** Add the same `category` and `priority` columns (with identical CHECK constraints) to `plans_archive` so archived rows are query-compatible with active plans.

---

## Phase 2: Programs, Program Plans & Risks Schema

- [x] **2.1** Update `001-initial-schema.sql` to replace the `programs` table skeleton with the full spec:

  ```sql
  CREATE TABLE programs (
    id               TEXT PRIMARY KEY,
    workspace_id     TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    title            TEXT NOT NULL,
    description      TEXT NOT NULL DEFAULT '',
    category         TEXT NOT NULL DEFAULT 'feature'
                       CHECK(category IN (
                         'feature','bugfix','refactor',
                         'orchestration','quick_task','advisory'
                       )),
    priority         TEXT NOT NULL DEFAULT 'medium'
                       CHECK(priority IN ('low','medium','high','critical')),
    status           TEXT NOT NULL DEFAULT 'active'
                       CHECK(status IN ('active','completed','archived','paused')),
    schema_version   TEXT NOT NULL DEFAULT '2.0',
    goals            TEXT NOT NULL DEFAULT '[]',   -- JSON: string[]
    success_criteria TEXT NOT NULL DEFAULT '[]',   -- JSON: string[]
    source           TEXT NOT NULL DEFAULT 'v2'
                       CHECK(source IN ('v2','v1_migrated')),
    created_at       TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at       TEXT NOT NULL DEFAULT (datetime('now')),
    archived_at      TEXT
  );
  ```

  **`source` column:** `'v2'` for programs created natively as `ProgramState`; `'v1_migrated'` for plans that had `is_program: true` converted during migration.

- [x] **2.2** Define the `program_plans` join table:

  ```sql
  CREATE TABLE program_plans (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    program_id  TEXT NOT NULL REFERENCES programs(id) ON DELETE CASCADE,
    plan_id     TEXT NOT NULL REFERENCES plans(id) ON DELETE CASCADE,
    order_index INTEGER NOT NULL DEFAULT 0,
    added_at    TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(program_id, plan_id)
  );

  CREATE INDEX idx_program_plans_program ON program_plans(program_id);
  CREATE INDEX idx_program_plans_plan    ON program_plans(plan_id);
  ```

- [x] **2.3** Define the `program_risks` table (new — not in Plan 3):

  ```sql
  CREATE TABLE program_risks (
    id                TEXT PRIMARY KEY,
    program_id        TEXT NOT NULL REFERENCES programs(id) ON DELETE CASCADE,
    risk_type         TEXT NOT NULL
                        CHECK(risk_type IN (
                          'functional_conflict',
                          'behavioral_change',
                          'dependency_risk'
                        )),
    severity          TEXT NOT NULL
                        CHECK(severity IN ('low','medium','high','critical')),
    description       TEXT NOT NULL,
    affected_plan_ids TEXT NOT NULL DEFAULT '[]',  -- JSON: string[]
    mitigation        TEXT,
    created_at        TEXT NOT NULL DEFAULT (datetime('now'))
  );

  CREATE INDEX idx_program_risks_program ON program_risks(program_id);
  ```

- [x] **2.4** Add `program-risks-db.ts` to the data access layer (see Phase 4).

---

## Phase 3: Dependencies Table Enhancement

The Plan 3 `dependencies` table is generic but lacks the `dep_type` and `dep_status` columns needed for program-level dependency semantics.

- [x] **3.1** Update the `dependencies` table in `001-initial-schema.sql`:

  ```sql
  CREATE TABLE dependencies (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    source_type TEXT NOT NULL
                  CHECK(source_type IN ('plan','phase','step','program')),
    source_id   TEXT NOT NULL,
    target_type TEXT NOT NULL
                  CHECK(target_type IN ('plan','phase','step','program')),
    target_id   TEXT NOT NULL,
    dep_type    TEXT NOT NULL DEFAULT 'blocks'
                  CHECK(dep_type IN ('blocks','informs')),
    dep_status  TEXT NOT NULL DEFAULT 'pending'
                  CHECK(dep_status IN ('pending','satisfied')),
    created_at  TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(source_type, source_id, target_type, target_id)
  );
  ```

  **`dep_type` semantics:**
  - `'blocks'` — the source cannot start/proceed until the target is complete
  - `'informs'` — the source should consider the target's output but is not blocked by it

  **`dep_status` semantics:**
  - `'pending'` — dependency not yet resolved
  - `'satisfied'` — target has reached a completed/archived state

- [x] **3.2** Update `server/src/db/dependency-db.ts` method signatures to include `dep_type` and `dep_status`:
  - `addDependency(sourceType, sourceId, targetType, targetId, depType?: 'blocks' | 'informs'): void`
  - `getDependencies(sourceType, sourceId, depType?: string): DependencyRow[]`
  - `markDependencySatisfied(sourceType, sourceId, targetType, targetId): void`
  - Update `DependencyRow` type in `types.ts` to include `dep_type` and `dep_status`

---

## Phase 4: Row Types & Data Access Layer Updates

- [x] **4.1** Update `server/src/db/types.ts` — add/update row type definitions:

  ```typescript
  export interface PlanRow {
    id: string;
    workspace_id: string;
    program_id: string | null;
    title: string;
    description: string;
    category: 'feature' | 'bugfix' | 'refactor' | 'orchestration' | 'quick_task' | 'advisory';
    priority: 'low' | 'medium' | 'high' | 'critical';
    status: 'active' | 'completed' | 'archived' | 'paused' | 'blocked';
    schema_version: string;
    goals: string;                  // JSON: string[]
    success_criteria: string;       // JSON: string[]
    categorization: string | null;  // JSON: CategorizationResult | null
    deployment_context: string | null;
    confirmation_state: string | null;
    paused_at: string | null;
    paused_at_snapshot: string | null; // JSON: PausedAtSnapshot | null
    recommended_next_agent: string | null;
    created_at: string;
    updated_at: string;
    archived_at: string | null;
    completed_at: string | null;
  }

  export interface ProgramRow {
    id: string;
    workspace_id: string;
    title: string;
    description: string;
    category: 'feature' | 'bugfix' | 'refactor' | 'orchestration' | 'quick_task' | 'advisory';
    priority: 'low' | 'medium' | 'high' | 'critical';
    status: 'active' | 'completed' | 'archived' | 'paused';
    schema_version: string;
    goals: string;           // JSON: string[]
    success_criteria: string; // JSON: string[]
    source: 'v2' | 'v1_migrated';
    created_at: string;
    updated_at: string;
    archived_at: string | null;
  }

  export interface ProgramPlanRow {
    id: number;
    program_id: string;
    plan_id: string;
    order_index: number;
    added_at: string;
  }

  export interface ProgramRiskRow {
    id: string;
    program_id: string;
    risk_type: 'functional_conflict' | 'behavioral_change' | 'dependency_risk';
    severity: 'low' | 'medium' | 'high' | 'critical';
    description: string;
    affected_plan_ids: string;  // JSON: string[]
    mitigation: string | null;
    created_at: string;
  }

  export interface DependencyRow {
    id: number;
    source_type: 'plan' | 'phase' | 'step' | 'program';
    source_id: string;
    target_type: 'plan' | 'phase' | 'step' | 'program';
    target_id: string;
    dep_type: 'blocks' | 'informs';
    dep_status: 'pending' | 'satisfied';
    created_at: string;
  }
  ```

- [x] **4.2** Update `server/src/db/plan-db.ts` — add type-aware query methods:
  - `getPlansByCategory(wsId: string, category: PlanRow['category']): PlanRow[]`
  - `getPausedPlans(wsId: string): PlanRow[]` — `WHERE paused_at IS NOT NULL`
  - `getChildPlans(programId: string): PlanRow[]` — `WHERE program_id = ?`
  - `getPlansByStatus(wsId: string, ...statuses: PlanRow['status'][]): PlanRow[]`
  - Ensure `getPlansByWorkspace` accepts an optional `{ category?, status?, programId? }` filter object

- [x] **4.3** Update `server/src/db/program-db.ts` — add risk management methods:
  - `addRisk(programId: string, risk: Omit<ProgramRiskRow, 'id' | 'program_id' | 'created_at'>): ProgramRiskRow`
  - `getRisks(programId: string): ProgramRiskRow[]`
  - `getRisk(riskId: string): ProgramRiskRow | null`
  - `deleteRisk(riskId: string): void`
  - `addPlanToProgram(programId: string, planId: string, orderIndex?: number): void`
  - `listProgramPlans(programId: string): ProgramPlanRow[]`
  - `removePlanFromProgram(programId: string, planId: string): void`

- [x] **4.4** Create `server/src/db/program-risks-db.ts` — standalone module for risk CRUD (same methods as 4.3 above, extracted for modularity if preferred by the implementing agent).

---

## Phase 5: Mappers & Category Normalization

- [ ] **5.1** Update `server/src/db/mappers.ts` — add the `planRowToState` mapper with full type-variant handling:

  ```typescript
  import { migrateCategoryToV2 } from '../types/context.types';

  export function planRowToState(row: PlanRow, phases: PhaseRow[], steps: StepRow[], ...): PlanState {
    return {
      plan_id: row.id,
      workspace_id: row.workspace_id,
      program_id: row.program_id ?? undefined,
      title: row.title,
      description: row.description,
      category: row.category,           // already normalized in DB
      priority: row.priority,
      status: row.status,
      schema_version: row.schema_version,
      goals: JSON.parse(row.goals),
      success_criteria: JSON.parse(row.success_criteria),
      categorization: row.categorization ? JSON.parse(row.categorization) : undefined,
      deployment_context: row.deployment_context ? JSON.parse(row.deployment_context) : undefined,
      confirmation_state: row.confirmation_state ? JSON.parse(row.confirmation_state) : undefined,
      paused_at_snapshot: row.paused_at_snapshot ? JSON.parse(row.paused_at_snapshot) : undefined,
      recommended_next_agent: row.recommended_next_agent ?? undefined,
      phases: phases.map(phaseRowToPhase),
      steps: steps.map(stepRowToStep),
      // ... sessions, lineage, notes from additional queries
    };
  }
  ```

- [ ] **5.2** Add `stateToPlanRow` (the inverse — used when creating or updating a plan from a `PlanState`):
  - Normalize `category`: if the incoming value is a legacy category, call `migrateCategoryToV2()` before inserting
  - Serialize all JSON columns: `JSON.stringify(goals)`, `JSON.stringify(success_criteria)`, etc.
  - Validate `category`, `priority`, `status` match the CHECK constraint values before inserting (throw on invalid, don't silently corrupt the DB)

- [ ] **5.3** Add `programRowToState` and `stateToProgramRow` mapper pair with the same pattern.

- [ ] **5.4** Add `dependencyRowToEdge` mapper — converts `DependencyRow` to the `PlanDependencyEdge` shape used by tool handlers:

  ```typescript
  export interface PlanDependencyEdge {
    sourceType: DependencyRow['source_type'];
    sourceId: string;
    targetType: DependencyRow['target_type'];
    targetId: string;
    type: 'blocks' | 'informs';
    status: 'pending' | 'satisfied';
  }
  ```

---

## Phase 6: Plan 4 Field Reference Audit

Update Plan 4 with the exact column names defined in this plan. This removes all vague "insert into X table" language from Plan 4.

- [x] **6.1** Update Plan 4, Phase 3.1 (`migrate-plans.ts`) — annotate the insert with the full column mapping:

  | `state.json` field | `plans` column | Transformation |
  |--------------------|----------------|----------------|
  | `plan_id` | `id` | Direct |
  | *(directory context)* | `workspace_id` | From enclosing workspace |
  | `program_id` | `program_id` | Nullable; null if absent |
  | `title` | `title` | Direct |
  | `description` | `description` | Default `''` if absent |
  | `category` | `category` | `migrateCategoryToV2(cat)` if v1; default `'feature'` if absent |
  | `priority` | `priority` | Default `'medium'` if absent |
  | `status` | `status` | Default `'active'` if absent |
  | *(always)* | `schema_version` | Hard-code `'2.0'` |
  | `goals` | `goals` | `JSON.stringify(v ?? [])` |
  | `success_criteria` | `success_criteria` | `JSON.stringify(v ?? [])` |
  | `categorization` | `categorization` | `JSON.stringify(v) ?? null` |
  | `deployment_context` | `deployment_context` | `JSON.stringify(v) ?? null` |
  | `confirmation_state` | `confirmation_state` | `JSON.stringify(v) ?? null` |
  | `paused_at_snapshot?.paused_at` | `paused_at` | Extracted timestamp or null |
  | `paused_at_snapshot` | `paused_at_snapshot` | `JSON.stringify(v) ?? null` |
  | `recommended_next_agent` | `recommended_next_agent` | Nullable |
  | `created_at` | `created_at` | Direct |
  | `updated_at` | `updated_at` | Fall back to `created_at` if absent |
  | `completed_at` | `completed_at` | Nullable |
  | `depends_on_plans[]` | *(not a column)* | Each entry → `dependencies` row: `{source_type: 'plan', source_id: plan_id, target_type: 'plan', target_id: dep_id, dep_type: 'blocks', dep_status: 'pending'}` |

- [x] **6.2** Update Plan 4, Phase 7.2 (`migrate-programs.ts` v2) — annotate the `programs` insert:

  | `program.json` field | `programs` column | Transformation |
  |----------------------|-------------------|----------------|
  | `id` | `id` | Direct |
  | *(workspace context)* | `workspace_id` | From enclosing workspace |
  | `title` | `title` | Direct |
  | `description` | `description` | Default `''` |
  | `category` | `category` | `migrateCategoryToV2(cat)` if needed; default `'feature'` |
  | `priority` | `priority` | Default `'medium'` |
  | `status` | `status` | Default `'active'` |
  | *(always)* | `schema_version` | Hard-code `'2.0'` |
  | `goals` | `goals` | `JSON.stringify(v ?? [])` |
  | `success_criteria` | `success_criteria` | `JSON.stringify(v ?? [])` |
  | *(always)* | `source` | `'v2'` |
  | `created_at` | `created_at` | Direct |
  | `updated_at` | `updated_at` | Fall back to `created_at` |

- [x] **6.3** Update Plan 4, Phase 7.2 — annotate the `program_plans` insert:
  - `program_id` ← program ID
  - `plan_id` ← each entry in `manifest.child_plan_ids`
  - `order_index` ← array position
  - `added_at` ← let the DB default (`datetime('now')`)

- [x] **6.4** Update Plan 4, Phase 7.2 — annotate the `dependencies` insert for program dependencies:
  - `source_type: 'plan'`, `source_id: dep.source_plan_id`
  - `target_type: 'plan'`, `target_id: dep.target_plan_id`
  - `dep_type: dep.type` (must be `'blocks'` or `'informs'`)
  - `dep_status: dep.status` (must be `'pending'` or `'satisfied'`)

- [x] **6.5** Update Plan 4, Phase 7.2 — annotate the `program_risks` insert:
  - `id` ← `risk.id` or `crypto.randomUUID()`
  - `program_id` ← program ID
  - `risk_type` ← `risk.risk_type`
  - `severity` ← `risk.severity`
  - `description` ← `risk.description`
  - `affected_plan_ids` ← `JSON.stringify(risk.affected_plan_ids ?? [])`
  - `mitigation` ← `risk.mitigation ?? null`

- [x] **6.6** Update Plan 4, Phase 7.3 — annotate the v1 program container → `programs` insert:
  - Same column mapping as 6.2 above
  - `source: 'v1_migrated'` (not `'v2'`)
  - `category`: apply `migrateCategoryToV2()` since v1 programs use legacy categories

---

## Phase 7: Schema & DB Reference Documentation

- [ ] **7.1** Create `docs/database-update-pmmcp/schema-reference.md` — the canonical living reference for the SQLite schema. Contents:

  ### Sections:
  - **Overview** — tech stack (`better-sqlite3`, WAL mode, FK enforcement), file location (`{DATA_ROOT}/project-memory.db`)
  - **Table Inventory** — table-by-table listing with purpose, estimated row count, and FK relationships
  - **Full DDL listing** — complete `001-initial-schema.sql` contents with inline comments explaining each table and significant column
  - **Enum values reference** — all `CHECK(column IN (...))` constraints grouped by domain:
    - Plan/Program category values + legacy migration map
    - Priority values
    - Status values (plans vs programs vs steps vs sessions)
    - Step types
    - Dependency types and statuses
    - Risk types and severities
  - **JSON column reference** — for each `TEXT` column that stores JSON, document the TypeScript type it serializes:
    - `plans.goals` → `string[]`
    - `plans.success_criteria` → `string[]`
    - `plans.categorization` → `CategorizationResult`
    - `plans.deployment_context` → `DeploymentContext`
    - `plans.confirmation_state` → `ConfirmationState`
    - `plans.paused_at_snapshot` → `PausedAtSnapshot`
    - `programs.goals` / `success_criteria` → `string[]`
    - `program_risks.affected_plan_ids` → `string[]`
    - `context_items.data` → any (typed by `parent_type + type`)
    - `steps.depends_on` → `number[]` (step indices within the plan)
  - **Index inventory** — every named index, what it speeds up, and which queries use it
  - **FK relationships** — full relationship table (parent table → child table → column → on-delete behavior)
  - **Archive procedure** — what `archivePlan(id)` does (tables involved, move vs copy, transaction semantics)
  - **Data access modules map** — `plan-db.ts → plans + phases`, `session-db.ts → sessions`, etc.
  - **Migration runner** — how `migration-runner.ts` tracks applied migrations, ordering rules, rollback policy

- [ ] **7.2** Create `docs/database-update-pmmcp/db-query-cookbook.md` — a reference of common query patterns:
  - Get all active plans for a workspace
  - Get all plans for a program (ordered by `program_plans.order_index`)
  - Get the next pending step for a plan (ordered by phase `order_index`, then step `order_index`)
  - Get full plan state (plan + phases + steps joined)
  - Search context items by type and parent
  - Get dependency chain for a plan (recursive CTE for transitive blockers)
  - List paused plans with their snapshot data
  - Archive a plan (complete transactional procedure)
  - Count plans by category across all workspaces

- [ ] **7.3** Add a "Data Access Module Index" section to `server/src/db/index.ts` as a JSDoc comment block that maps tool handler operations to the DB module that implements them (e.g., `memory_plan(action: 'create')` → `plan-db.ts: createPlan()`).

---

## Phase 8: Build & Verify

- [ ] **8.1** `npm run build` in `server/` — all updated type files and data access modules compile cleanly.
- [ ] **8.2** Run `npx vitest run` in `server/` — existing tests still pass; new row-type and mapper tests pass.
- [ ] **8.3** Write a quick schema-smoke test: open the DB, insert one row of each new table (`programs`, `program_plans`, `program_risks`), verify CHECK constraints reject invalid values (e.g., `category = 'invalid'` should throw `SQLITE_CONSTRAINT`).
- [ ] **8.4** Verify the `dependencies` table rejects unknown `dep_type` and `dep_status` values via constraint.
- [ ] **8.5** Verify `plans.program_id` → `programs.id` FK with `ON DELETE SET NULL`: delete a program, confirm child plans' `program_id` becomes `NULL` (not deleted).

---

## References

### New Files

| Path | Purpose |
|------|---------|
| `server/src/db/migrations/001-initial-schema.sql` | Updated with precise plans/programs/dependencies DDL |
| `server/src/db/program-risks-db.ts` | CRUD for `program_risks` table |
| `docs/database-update-pmmcp/schema-reference.md` | Full schema DDL, enum reference, JSON column types, index inventory |
| `docs/database-update-pmmcp/db-query-cookbook.md` | Common query patterns with SQL examples |

### Modified Files

| Path | Change |
|------|--------|
| `server/src/db/types.ts` | Add `PlanRow`, `ProgramRow`, `ProgramPlanRow`, `ProgramRiskRow`, `DependencyRow` with all columns |
| `server/src/db/plan-db.ts` | Add category/status/paused filter methods |
| `server/src/db/program-db.ts` | Add risk management + `program_plans` methods |
| `server/src/db/dependency-db.ts` | Add `dep_type`, `dep_status` to all signatures |
| `server/src/db/mappers.ts` | `planRowToState`, `stateToPlanRow`, category normalization |
| `server/src/db/index.ts` | JSDoc data access module index |
| `docs/database-update-pmmcp/04-data-migration.md` | Phase 3.1 and 7.x annotated with exact column names |

### Schema Quick Reference (for Plan 4 implementors)

| Table | Primary columns relevant to plan types |
|-------|----------------------------------------|
| `plans` | `id, workspace_id, program_id, category, priority, status, schema_version, goals, success_criteria, categorization, paused_at, paused_at_snapshot, recommended_next_agent` |
| `programs` | `id, workspace_id, category, priority, status, source, goals, success_criteria` |
| `program_plans` | `program_id, plan_id, order_index` (UNIQUE on both) |
| `program_risks` | `program_id, risk_type, severity, description, affected_plan_ids, mitigation` |
| `dependencies` | `source_type, source_id, target_type, target_id, dep_type, dep_status` |
