# Plan 4.5: Relational Gap Closure & File Edit History

**Category:** Feature  
**Priority:** Critical  
**Status:** Schema Done — DAL Pending  
**Parent Program:** [Database Migration & System Stabilization](00-program-overview.md)  
**Dependencies:** Plan 4 (Data Migration) — must run after migration is complete  
**Blocks:** Plan 5 (MCP Server Storage Replacement) — Plan 5 tool handlers must be built on the corrected schema  
**Workspace Directory:** `C:\Users\User\Project_Memory_MCP\Project-Memory-MCP`

## Goal

The original QA established three relational requirements that are present in spirit across Plans 3–4 but were never fully specified or implemented. A fourth capability — file edit history — is added here as a forward-looking feature that the same schema and tool layer can support cleanly:

1. **Cross-workspace program→plan links** — Integrated Programs must be able to relate to plans in *other* workspaces. The `program_workspace_links` table was named in Plan 3 but never given DDL, a data access module, or a migration step.

2. **Relational step dependencies** — The QA asked for dependent plans/phases/steps defined relationally (*"when step x must be complete before y"*). The `dependencies` DAG table supports this, but `steps.depends_on` is still a JSON integer array (within-plan step indices inherited from the existing system). Step-to-step dependencies must be normalised into the `dependencies` table so that *all* dependency relationships are relational and queryable — not split between a JSON column and the DAG table.

3. **Research documents linked at all planning levels** — The QA asked for context and research linked to *"plans and all planning types"*. `research_documents` currently only has a `plan_id` FK. Phases and steps must be linkable targets too, using the same polymorphic `(parent_type, parent_id)` pattern already established by `context_items`.

4. **File edit history per step** — Every file touched during a plan step can be recorded in a `step_file_edits` table. This creates a living, queryable history of file changes across plans, surfaced through `memory_steps` (write path) and `memory_context` (query path). Best-effort back-fill from existing plan data is included; no migration failure if historical data is sparse.

All four items must be in place before Plan 5 builds tool handlers, because:
- Plan 5's `memory_steps` tool needs to read step dependencies from `dependencies`, not a JSON column
- Plan 5's `memory_context` tool search must be able to find research notes attached to phases and steps, and query file edit history
- Plan 5's program tools must support cross-workspace membership
- Plan 5's `memory_steps(action: 'update')` handler needs the `step_file_edits` table to exist before wiring up the `files_modified` parameter

---

## Phase 1: `program_workspace_links` — DDL & Data Access

The `program_workspace_links` table enables a program in workspace A to include plans from workspace B. The `program_plans` join table (Plan 3.5) handles same-workspace membership; `program_workspace_links` registers which workspaces a program has reach into.

- [x] **1.1** Add to `server/src/db/migrations/001-initial-schema.sql`:

  ```sql
  -- Cross-workspace program visibility
  -- One row per (program, foreign workspace) pair.
  -- Plans in that workspace can then be added to program_plans normally.
  CREATE TABLE program_workspace_links (
    id           INTEGER PRIMARY KEY AUTOINCREMENT,
    program_id   TEXT NOT NULL REFERENCES programs(id) ON DELETE CASCADE,
    workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    linked_at    TEXT NOT NULL DEFAULT (datetime('now')),
    linked_by    TEXT,  -- agent type or 'user' that created the link
    UNIQUE(program_id, workspace_id)
  );

  CREATE INDEX idx_pwl_program   ON program_workspace_links(program_id);
  CREATE INDEX idx_pwl_workspace ON program_workspace_links(workspace_id);
  ```

  **Semantics:**
  - A row in this table means the program has declared membership reach into the linked workspace.
  - It does **not** automatically add all plans from that workspace — it gates which workspaces the program can pull from when `program_plans` references are created.
  - A program always implicitly has reach into its own workspace (`programs.workspace_id`); `program_workspace_links` only records *additional* workspaces.
  - The `program_plans` table already allows `plan_id` from any workspace (no workspace constraint on its FK), so this table is the access control / discovery layer.

- [ ] **1.2** Create `server/src/db/program-workspace-links-db.ts`:

  ```typescript
  // Link a program to an additional workspace (enables cross-workspace plan membership)
  linkWorkspace(programId: string, workspaceId: string, linkedBy?: string): void

  // Remove a workspace link (does NOT remove program_plans entries for plans from that workspace)
  unlinkWorkspace(programId: string, workspaceId: string): void

  // Get all workspaces a program has reach into (including its own)
  getLinkedWorkspaces(programId: string): ProgramWorkspaceLinkRow[]

  // Get all programs visible in a specific workspace (own programs + programs with a link row)
  getProgramsVisibleInWorkspace(workspaceId: string): ProgramRow[]

  // Check whether a program can accept a plan from a given workspace
  canAcceptPlanFromWorkspace(programId: string, planWorkspaceId: string): boolean
  ```

- [x] **1.3** Add `ProgramWorkspaceLinkRow` to `server/src/db/types.ts`:

  ```typescript
  export interface ProgramWorkspaceLinkRow {
    id: number;
    program_id: string;
    workspace_id: string;
    linked_at: string;
    linked_by: string | null;
  }
  ```

- [ ] **1.4** Update `server/src/db/program-db.ts` — add cross-workspace helpers:
  - `addPlanToProgram`: before inserting into `program_plans`, call `canAcceptPlanFromWorkspace()`. If the plan is from a different workspace and no link exists, either throw or auto-create the link (configurable, default: throw with a helpful error message).
  - `listProgramPlans(programId)`: join `program_plans` → `plans` → `workspaces` so the returned rows include `workspace_id` and `workspace_name` for display.

- [ ] **1.5** Update `server/src/db/mappers.ts` — add `programWorkspaceLinkRowToLink()` mapper.

---

## Phase 2: Step Dependency Normalisation

The existing system stores within-plan step dependencies as `depends_on: number[]` on each step (step indices). This is inconsistent with the `dependencies` DAG table and prevents:
- Querying "which steps are blocked by step X?" without loading the entire plan
- Cross-phase step dependencies being expressed cleanly
- Tool handlers staying DB-only (they'd still need to manipulate JSON arrays)

- [x] **2.1** Decide and document the final column spec for `steps`:
  - **Remove** `depends_on TEXT` (JSON integer array) from the `steps` table in `migrations/001-initial-schema.sql`
  - Step-to-step dependencies are expressed *exclusively* via the `dependencies` table:
    `{ source_type: 'step', source_id: step.id, target_type: 'step', target_id: dep_step.id, dep_type: 'blocks', dep_status: 'pending' | 'satisfied' }`

- [x] **2.2** Update `migrations/001-initial-schema.sql` — remove `depends_on` column from `steps` DDL. The `dependencies` table already has the correct structure (Plan 3.5, Phase 3.1).

- [ ] **2.3** Update `server/src/db/types.ts` — remove `depends_on` field from `StepRow`.

- [ ] **2.4** Update `server/src/db/step-db.ts` — add dependency-aware methods:
  - `getStepDependencies(stepId: string): DependencyRow[]` — steps that must complete before this one
  - `getStepDependents(stepId: string): DependencyRow[]` — steps that are blocked by this one
  - `addStepDependency(stepId: string, dependsOnStepId: string): void` — creates `dependencies` row
  - `removeStepDependency(stepId: string, dependsOnStepId: string): void`
  - `markStepDependencySatisfied(stepId: string, dependsOnStepId: string): void` — sets `dep_status: 'satisfied'`
  - `getNextPendingStep(planId: string): StepRow | null` — updated to check that all `dependencies` rows for the candidate step have `dep_status: 'satisfied'` before returning it

- [ ] **2.5** Update `server/src/db/mappers.ts` — `stepRowToStep()` must now load dependencies via `getStepDependencies()` and reconstruct a `depends_on` array of step IDs (not indices) for consumers that still need it. Clearly document that the public `PlanStep` type is being moved from index-based `depends_on: number[]` to ID-based `depends_on: string[]`.

- [ ] **2.6** Update `server/src/migration/migrate-plans.ts` (from Plan 4) — add a post-insert pass that:
  - For each migrated step that has a `depends_on: number[]` value in `state.json`
  - Resolve each index to the corresponding step's `id` (looked up from the step rows inserted earlier in the same plan migration)
  - Insert a `dependencies` row for each resolved pair: `{ source_type: 'step', source_id: step.id, target_type: 'step', target_id: resolved_step.id, dep_type: 'blocks', dep_status: 'pending' }`
  - If a step has `status: 'done'` already, mark the edge `dep_status: 'satisfied'`

- [ ] **2.7** Write a post-migration validation pass: for every migrated step that had `depends_on` indices in the source JSON, confirm a corresponding `dependencies` row exists in the DB. Log counts in the migration report.

---

## Phase 3: Research Documents — Polymorphic Linking

`research_documents` currently has `plan_id` and `workspace_id` FKs — no way to attach research notes to a specific phase or step. The QA asked for context and research linked at *all planning levels*.

- [x] **3.1** Update `migrations/001-initial-schema.sql` — replace the `research_documents` column spec:

  ```sql
  CREATE TABLE research_documents (
    id           INTEGER PRIMARY KEY AUTOINCREMENT,
    workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    -- Polymorphic parent (plan, phase, or step — or just workspace-level)
    parent_type  TEXT NOT NULL DEFAULT 'plan'
                   CHECK(parent_type IN ('workspace','plan','phase','step')),
    parent_id    TEXT,  -- NULL only when parent_type = 'workspace' (workspace-scoped research)
    filename     TEXT NOT NULL,
    content      TEXT NOT NULL,
    created_at   TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at   TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(workspace_id, parent_type, parent_id, filename)
  );

  CREATE INDEX idx_research_workspace  ON research_documents(workspace_id);
  CREATE INDEX idx_research_parent     ON research_documents(parent_type, parent_id);
  ```

  **Semantics:**

  | `parent_type` | `parent_id` | Example use |
  |---------------|-------------|-------------|
  | `'workspace'` | `NULL` | Workspace-wide research notes (not tied to any plan) |
  | `'plan'` | `plan_id` | Existing Plan 3/4 usage — research attached to a plan |
  | `'phase'` | `phase_id` | Research notes specific to a phase (e.g., investigation into one part of a plan) |
  | `'step'` | `step_id` | Research notes attached to a specific task (rare but supported) |

- [ ] **3.2** Update `server/src/db/types.ts` — update `ResearchDocumentRow`:

  ```typescript
  export interface ResearchDocumentRow {
    id: number;
    workspace_id: string;
    parent_type: 'workspace' | 'plan' | 'phase' | 'step';
    parent_id: string | null;
    filename: string;
    content: string;
    created_at: string;
    updated_at: string;
  }
  ```

- [ ] **3.3** Update `server/src/db/research-db.ts` — update all method signatures:

  ```typescript
  appendResearch(
    wsId: string,
    parentType: ResearchDocumentRow['parent_type'],
    parentId: string | null,
    filename: string,
    content: string
  ): void

  getResearch(
    wsId: string,
    parentType: ResearchDocumentRow['parent_type'],
    parentId: string | null,
    filename: string
  ): string | null

  listResearch(
    wsId: string,
    parentType: ResearchDocumentRow['parent_type'],
    parentId: string | null
  ): string[]             // returns filenames

  getResearchDocument(id: number): ResearchDocumentRow | null

  // Convenience wrappers (backwards-compatible call sites)
  appendPlanResearch(wsId: string, planId: string, filename: string, content: string): void
  listPlanResearch(wsId: string, planId: string): string[]
  ```

- [ ] **3.4** Update `server/src/migration/migrate-research.ts` (from Plan 4) — all migrated research notes continue to use `parent_type: 'plan'` (correct, since all existing research is plan-scoped). The `parent_id` column receives the `plan_id`. No data loss — this is a structural extension, not a format change.

- [ ] **3.5** Update `server/src/db/mappers.ts` — update `researchDocumentRowToNote()` to include `parent_type` and `parent_id` in the mapped output.

---

## Phase 4: `step_file_edits` — File Edit History

Every file touched as part of a plan step can be recorded in `step_file_edits`. This creates a living, queryable history of which files changed during which step — surfaced through `memory_steps` and `memory_context` tool actions in Plan 5.

- [x] **4.1** Add to `server/src/db/migrations/001-initial-schema.sql`:

  ```sql
  -- Per-step file edit history.
  -- step_id is nullable: edits discovered via migration scraping may not resolve to a step.
  CREATE TABLE step_file_edits (
    id            INTEGER PRIMARY KEY AUTOINCREMENT,
    workspace_id  TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    plan_id       TEXT NOT NULL REFERENCES plans(id) ON DELETE CASCADE,
    step_id       TEXT REFERENCES steps(id) ON DELETE SET NULL,
    file_path     TEXT NOT NULL,    -- relative to workspace root
    change_type   TEXT NOT NULL DEFAULT 'edit'
                    CHECK(change_type IN ('create','edit','delete','rename')),
    previous_path TEXT,             -- only populated for rename operations
    edited_at     TEXT NOT NULL DEFAULT (datetime('now')),  -- ISO-8601 datetime
    agent_type    TEXT,             -- which agent type performed the edit
    session_id    TEXT,             -- agent session that caused the edit
    notes         TEXT
  );

  CREATE INDEX idx_sfe_workspace ON step_file_edits(workspace_id);
  CREATE INDEX idx_sfe_plan      ON step_file_edits(plan_id);
  CREATE INDEX idx_sfe_step      ON step_file_edits(step_id);
  CREATE INDEX idx_sfe_file_path ON step_file_edits(file_path);
  CREATE INDEX idx_sfe_edited_at ON step_file_edits(edited_at);
  ```

  **Semantics:**
  - `file_path` is relative to the workspace root (e.g., `server/src/db/step-db.ts`). Relative paths keep records valid if the workspace directory is moved.
  - `step_id` is nullable because best-effort migration scraping may only resolve to plan level, not a specific step.
  - `change_type: 'rename'` uses `previous_path` for the pre-rename path; `file_path` holds the new path.
  - `edited_at` is a single ISO-8601 datetime string. SQLite's `date(edited_at)` and `time(edited_at)` extract date and time components when needed for display.
  - No UNIQUE constraint is enforced: the same file can legitimately be edited multiple times within a single step.

- [ ] **4.2** Create `server/src/db/file-edits-db.ts`:

  ```typescript
  // Record one file edit event.
  // Primary write path: called by memory_steps tool handler when files_modified is supplied.
  recordFileEdit(
    wsId: string,
    planId: string,
    stepId: string | null,
    filePath: string,
    changeType: 'create' | 'edit' | 'delete' | 'rename',
    options?: {
      previousPath?: string;
      agentType?: string;
      sessionId?: string;
      notes?: string;
      editedAt?: string;  // override timestamp (used by migration scraping)
    }
  ): number  // returns new row id

  // Full edit history for one file across all plans and steps (newest first)
  getFileEditHistory(wsId: string, filePath: string): FileEditRow[]

  // All files touched within a specific step
  getStepFileEdits(stepId: string): FileEditRow[]

  // All files touched across an entire plan (ordered by edited_at)
  getPlanFileEdits(planId: string): FileEditRow[]

  // File path pattern search — supports % SQLite LIKE wildcards
  // e.g. searchFileEdits(wsId, 'server/src/%') returns all server/src edits
  searchFileEdits(wsId: string, pathPattern: string): FileEditRow[]
  ```

- [x] **4.3** Add `FileEditRow` to `server/src/db/types.ts`:

  ```typescript
  export interface FileEditRow {
    id: number;
    workspace_id: string;
    plan_id: string;
    step_id: string | null;
    file_path: string;
    change_type: 'create' | 'edit' | 'delete' | 'rename';
    previous_path: string | null;
    edited_at: string;
    agent_type: string | null;
    session_id: string | null;
    notes: string | null;
  }
  ```

- [ ] **4.4** Hook `recordFileEdit` into the `memory_steps` tool `update` action (Plan 5 task reference):
  - Add an optional `files_modified` parameter:
    `files_modified?: Array<{ path: string; change_type?: 'create' | 'edit' | 'delete' | 'rename'; notes?: string }>`
  - When supplied (typically alongside `status: 'done'`), the handler calls `recordFileEdit()` for each entry, inheriting `workspace_id`, `plan_id`, `step_id`, and `session_id` from the request context.
  - This is the primary write path for forward-going agent sessions. Agents call `memory_steps(action: 'update', step_index: N, status: 'done', files_modified: [...])` and the history is recorded in a single request.
  - Document this parameter in Plan 5's tool handler spec but make the table here so the schema is ready.

- [ ] **4.5** Add `file_history` action to `memory_context` tool (Plan 5 task reference):
  - Action: `memory_context(action: 'file_history', workspace_id, file_path)`
  - Returns: `FileEditRow[]` ordered by `edited_at DESC` — full audit trail for a given file path showing which plans, phases, and steps touched it and when.
  - Enables agents and the dashboard to ask *"what plans have modified `server/src/db/step-db.ts`?"* without filesystem scanning.
  - Document the action here; the tool handler implementation is Plan 5's responsibility.

- [ ] **4.6** Best-effort migration — create `server/src/migration/migrate-file-edits.ts`:

  Scrape existing plan data for recoverable file paths (in priority order per plan):

  | Source | Fields to look for | Notes |
  |--------|--------------------|-------|
  | `execution_log` context items | `files_created`, `files_modified`, `artifacts` arrays | Most reliable source |
  | Session `artifacts` arrays in `state.json` | `sessions[].artifacts` | Common on completed sessions |
  | Handoff lineage `data.files_modified` | `lineage[].data.files_modified` | Present on Executor handoffs |

  For each file path found:
  - Insert a `step_file_edits` row with `step_id: null`, `change_type: 'edit'` (conservative default — actual change type cannot be determined from log snippets)
  - `edited_at` from the source session's `completed_at` or `started_at` if available; fall back to the plan's `updated_at`
  - `notes: 'v1_migrated_best_effort'`

  Migration behaviour:
  - **Non-fatal** — if a plan has no recoverable file data, log it and move on; do not fail the overall migration
  - Log per-plan and total statistics in the migration report: plans scanned, rows inserted, plans with zero recoverable paths
  - Deduplication: skip inserting a row if `(plan_id, file_path, edited_at)` already exists (use INSERT OR IGNORE)

---

## Phase 5: Schema File & Documentation Updates

- [ ] **5.1** Update `docs/database-update-pmmcp/schema-reference.md` (created in Plan 3.5, Phase 7) to add:
  - `program_workspace_links` table entry in the Table Inventory, full DDL, and FK relationship row
  - Note on `steps` table: `depends_on` column removed, replaced by `dependencies` table edges
  - Updated `research_documents` DDL showing `parent_type`/`parent_id` columns
  - Updated `ResearchDocumentRow` in the JSON column reference section
  - `step_file_edits` table entry: full DDL, index list, `FileEditRow` type definition, `edited_at` date/time extraction note

- [ ] **5.2** Update `docs/database-update-pmmcp/db-query-cookbook.md` (Plan 3.5, Phase 7) to add:
  - **Get all workspaces a program is visible in**: `program_workspace_links` + `workspaces` join
  - **Get all plans in a program across workspaces**: `program_plans` → `plans` → `workspaces` join showing workspace name
  - **Get unblocked pending steps for a plan**: steps where no `dependencies` row exists with `dep_status: 'pending'` and `target_id = step.id`
  - **Mark a step's dependencies satisfied on completion**: `UPDATE dependencies SET dep_status = 'satisfied' WHERE source_type = 'step' AND target_id = ?` (when a step is marked done)
  - **List research notes attached to a phase**: `SELECT * FROM research_documents WHERE parent_type = 'phase' AND parent_id = ?`
  - **Get full edit history for a file**: `SELECT sfe.*, p.title AS plan_title FROM step_file_edits sfe JOIN plans p ON p.id = sfe.plan_id WHERE sfe.workspace_id = ? AND sfe.file_path = ? ORDER BY sfe.edited_at DESC`
  - **All files touched in a plan**: `SELECT DISTINCT file_path, change_type, count(*) AS edit_count FROM step_file_edits WHERE plan_id = ? GROUP BY file_path ORDER BY edited_at`
  - **Files edited by a specific step**: `SELECT * FROM step_file_edits WHERE step_id = ? ORDER BY edited_at`

---

## Phase 6: Build & Verify

- [ ] **6.1** `npm run build` in `server/` — migration DDL changes, new types, updated data access modules all compile cleanly.
- [ ] **6.2** Schema smoke tests:
  - Insert a cross-workspace `program_workspace_links` row; verify `canAcceptPlanFromWorkspace()` returns `true`
  - Attempt to link two plans as step dependencies via the `dependencies` table; verify `getNextPendingStep()` skips the blocked step
  - Mark the blocker step as done; verify the dependent step becomes the next candidate
  - Try inserting a `steps` row with the old `depends_on` JSON column — confirm the column no longer exists (migration applied correctly)
- [ ] **6.3** Research linking smoke tests:
  - Insert a research note with `parent_type: 'phase'`; verify it's retrieved by `listResearch(wsId, 'phase', phaseId)`
  - Verify the UNIQUE constraint on `(workspace_id, parent_type, parent_id, filename)` prevents duplicate filenames at the same scope
- [ ] **6.4** File edit history smoke tests:
  - Call `recordFileEdit(wsId, planId, stepId, 'server/src/db/step-db.ts', 'edit', { agentType: 'Executor' })`; verify row is inserted
  - Call `getFileEditHistory(wsId, 'server/src/db/step-db.ts')`; verify the row is returned in newest-first order
  - Call `searchFileEdits(wsId, 'server/src/%')`; verify all `server/src/` edits are returned
  - Insert a rename row with `change_type: 'rename'`, `previous_path: 'old.ts'`, `file_path: 'new.ts'`; verify `previous_path` is stored
  - Run `migrate-file-edits.ts` against a plan with a known `execution_log` context item; verify at minimum one row is inserted with `notes: 'v1_migrated_best_effort'`
- [ ] **6.5** Run `npx vitest run` in `server/` — all existing tests pass; no regressions from schema changes.

---

## References

### Gap Origin

| Item | Source | Previously Missed In |
|------|--------|---------------------|
| `program_workspace_links` DDL & data access | QA: *"Integrated Programs...should have the ability to have relations to plans in other workspaces"* | Plans 3, 3.5 (table named but never specified) |
| Step dependency normalisation | QA: *"It needs to be possible to define dependent plans/phases/steps relationally to each other"* | Plans 3, 3.5, 4 (JSON array never replaced) |
| Research docs at all planning levels | QA: *"define relational links between context and research to plans and all planning types"* | Plans 3, 4 (`plan_id` FK only) |
| `step_file_edits` table & file history | New feature addition — living audit trail of file changes per step | Not previously specified |

### New / Changed Files

| Path | Change |
|------|--------|
| `server/src/db/migrations/001-initial-schema.sql` | Add `program_workspace_links`; remove `steps.depends_on`; extend `research_documents` with `parent_type`/`parent_id`; add `step_file_edits` with indexes |
| `server/src/db/program-workspace-links-db.ts` | **New** — CRUD for cross-workspace program links |
| `server/src/db/file-edits-db.ts` | **New** — `recordFileEdit`, `getFileEditHistory`, `getStepFileEdits`, `getPlanFileEdits`, `searchFileEdits` |
| `server/src/db/types.ts` | Add `ProgramWorkspaceLinkRow`, `FileEditRow`; update `StepRow` (remove `depends_on`); update `ResearchDocumentRow` |
| `server/src/db/step-db.ts` | Add dependency-aware step methods; update `getNextPendingStep` to check `dependencies` table |
| `server/src/db/research-db.ts` | Polymorphic parent (`parent_type`, `parent_id`) on all methods |
| `server/src/db/program-db.ts` | Cross-workspace guards in `addPlanToProgram`; workspace-joined `listProgramPlans` |
| `server/src/db/mappers.ts` | Updated `stepRowToStep` (ID-based `depends_on`), `researchDocumentRowToNote` |
| `server/src/migration/migrate-plans.ts` | Post-insert pass to normalise `depends_on` indices → `dependencies` rows |
| `server/src/migration/migrate-research.ts` | Set `parent_type: 'plan'`, `parent_id: plan_id` on all migrated notes |
| `server/src/migration/migrate-file-edits.ts` | **New** — best-effort scrape of `execution_log`, session artifacts, and handoff data into `step_file_edits` |
| `docs/database-update-pmmcp/schema-reference.md` | Add `program_workspace_links`, `step_file_edits`; note `steps.depends_on` removal; update `research_documents` |
| `docs/database-update-pmmcp/db-query-cookbook.md` | Add cross-workspace, step-dep, phase-research, and file history query examples |
