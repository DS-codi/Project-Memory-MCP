{
  "id": "plan_mlpksy83_d5222084",
  "workspace_id": "project_memory_mcp-50e04147a402",
  "title": "Subagent Session Interruption & Injection System",
  "description": "Add real-time interrupt and inject capabilities for running subagent sessions. The system intercepts MCP tool responses at the extension layer to deliver stop directives and user-provided refinements to active subagents. Sessions are identified by workspace_id + plan_id + session_id triple, with an is_subagent flag on tool calls. The extension panel displays active sessions with stop/inject controls. Hub agents detect orphaned sessions on re-init for recovery.",
  "priority": "high",
  "category": "feature",
  "goals": [
    "Enable users to gracefully stop a running subagent mid-execution via tool response interception",
    "Enable users to inject small refinements/corrections into a running subagent session",
    "Display active subagent sessions in the VS Code extension sidebar panel with real-time status",
    "Support multiple simultaneous chat instances with isolated session tracking via triple-ID keying",
    "Detect orphaned/lost subagent sessions when hub agents re-initialize",
    "Maintain backward compatibility ‚Äî transparent session detection via _session_id meta-field, no tool schema changes"
  ],
  "success_criteria": [
    "Stop button in extension panel causes targeted subagent to receive stop directive on next tool call and hand off gracefully (3-level escalation)",
    "Inject input delivers user text to targeted subagent prepended to next tool response with 500-char limit and sanitization",
    "Session list in sidebar shows all active subagent sessions with agent type, plan, elapsed time, last tool call",
    "Triple-ID keying (workspace_id + plan_id + session_id) correctly isolates concurrent sessions",
    "Hub agent init detects orphaned subagent sessions and returns structured warnings",
    "Non-subagent tool calls (no _session_id in input) pass through completely unchanged ‚Äî no schema changes in package.json",
    "Session registry persists across extension reloads via context.workspaceState",
    "Hub agents receive notification when child subagent is stopped (parent propagation)",
    "All new files under 300 lines, no monolithic modules"
  ],
  "status": "active",
  "current_phase": "Phase 1: Session Types & Registry (Extension-Side)",
  "current_agent": "Coordinator",
  "confirmation_state": {
    "phases": {},
    "steps": {}
  },
  "created_at": "2026-02-16T19:37:16.615Z",
  "updated_at": "2026-02-16T20:04:56.750Z",
  "agent_sessions": [
    {
      "session_id": "sess_mlpkt241_96544da6",
      "agent_type": "Coordinator",
      "started_at": "2026-02-16T19:37:21.649Z",
      "context": {
        "deployed_by": "user",
        "reason": "Orchestrate Subagent Session Interruption & Injection System feature - create plan, route through Architect -> Researcher -> Architect for refined plan",
        "run_id": "run_sess_mlpkt241_96544da6"
      }
    },
    {
      "session_id": "sess_mlpkv08p_a8f40dab",
      "agent_type": "Architect",
      "started_at": "2026-02-16T19:38:52.557Z",
      "context": {
        "deployed_by": "Coordinator",
        "reason": "Design initial phased implementation plan for Subagent Session Interruption & Injection System",
        "audit_summary": "Brainstorm agent identified architecture: SessionInterceptRegistry, ToolProvider interception hook, stop/inject protocols, extension panel UI, server-side audit",
        "research_summary": "Pending ‚Äî Researcher will gather codebase context after this first-pass plan",
        "constraints": [
          "Extension-side only for session registry and interception",
          "Server-side for audit/persistence",
          "Must integrate with existing ToolProvider dispatch and active-run-registry",
          "No breaking changes to existing spawn flow"
        ],
        "acceptance_criteria": [
          "Subagent sessions can be interrupted via stop directive",
          "User text can be injected into active subagent sessions",
          "Extension panel shows active sessions with stop/inject controls",
          "Server-side audit trail for all session lifecycle events",
          "Orphaned sessions detected and recovered"
        ],
        "run_id": "run_sess_mlpkv08p_a8f40dab"
      },
      "completed_at": "2026-02-16T19:41:54.577Z",
      "summary": "Designed first-pass implementation plan: 35 steps across 9 phases for the Subagent Session Interruption & Injection System.\\n\\n**Phases:**\\n1. Session Registry & Identity (4 steps) ‚Äî SessionInterceptRegistry class, types, persistence, activation wiring\\n2. Session Token Protocol (4 steps) ‚Äî spawn-agent session_id minting, tool handler schema updates, ToolProvider registration, server-side validation\\n3. ToolProvider Interception Layer (3 steps) ‚Äî interceptor module, ToolProvider integration, lastToolCall tracking\\n4. Stop Protocol (3 steps) ‚Äî 3-level escalation directives, auto-escalation logic, hub propagation\\n5. Inject Protocol (2 steps) ‚Äî inject delivery, text validation/sanitization\\n6. Extension Panel UI (4 steps) ‚Äî sessions-section HTML, DashboardViewProvider integration, message handlers, real-time refresh\\n7. Server-Side Audit & Recovery (3 steps) ‚Äî lifecycle events, audit metadata, orphaned session detection\\n8. Agent Instruction Updates (4 steps) ‚Äî new instruction file, update recovery/handoff docs, update agent files\\n9. Testing & Integration (8 steps) ‚Äî unit tests, integration tests, build verification, code review\\n\\n**Research Gaps:** 10 files need Researcher investigation for exact interfaces and patterns. Stored in architecture.json.\\n\\n**File Map:** 7 new files, 18 modified files. Stored in architecture context.\\n\\nRecommended next: Researcher to investigate research gaps, then Architect second pass to refine steps.\"",
      "artifacts": []
    },
    {
      "session_id": "sess_mlpl0nv6_16924978",
      "agent_type": "Researcher",
      "started_at": "2026-02-16T19:43:16.463Z",
      "context": {
        "deployed_by": "Coordinator",
        "reason": "Investigate 12 research gaps for Subagent Session Interruption & Injection System plan",
        "research_targets": [
          "ToolProvider dispatch pattern",
          "Active Run Registry API",
          "Spawn Agent Tool enrichment",
          "Tool handler structure",
          "DashboardViewProvider sections",
          "Dashboard webview sections",
          "Dashboard message handlers",
          "Server memory_agent handler",
          "Server event emitter",
          "Stale run recovery",
          "Extension activation pattern",
          "Tool parameter schema format"
        ],
        "questions_to_answer": [
          "How are tools registered and dispatched?",
          "What is LaneState and ActiveRunLifecycleRecord?",
          "How is enriched_prompt composed?",
          "How do dashboard webview sections work?",
          "How does the server init action handler work?",
          "What event types exist?"
        ],
        "run_id": "run_sess_mlpl0nv6_16924978"
      },
      "completed_at": "2026-02-16T19:51:28.673Z",
      "summary": "Investigated all 12 research gaps for the Subagent Session Interruption & Injection System plan. Documented exact interfaces, function signatures, response shapes, and code patterns for: ToolProvider dispatch (Gap 1), Active Run Registry API (Gap 2), Spawn Agent enrichment flow (Gap 3), Tool handler structure (Gap 4), DashboardViewProvider sections (Gap 5), Dashboard webview section pattern (Gap 6), Dashboard message handlers (Gap 7), Server memory_agent init handler (Gap 8), Server event emitter (Gap 9), Stale run recovery (Gap 10), Extension activation pattern (Gap 11), and Tool parameter schema format (Gap 12). Key findings: (1) Interception should happen at ToolProvider invoke level, not inside handlers; (2) active-run-registry has NO persistence ‚Äî SessionInterceptRegistry MUST use context.workspaceState; (3) spawn-agent-tool is the best place to mint session_id; (4) Tool schemas should NOT expose is_subagent/session_id to the LM model; (5) Dashboard sections follow a consistent HTML+JS pattern that can be replicated exactly for sessions. All findings stored in research_notes/codebase-investigation.md and research.json.\""
    },
    {
      "session_id": "sess_mlplcxmq_d0affb2c",
      "agent_type": "Architect",
      "started_at": "2026-02-16T19:52:48.983Z",
      "context": {
        "deployed_by": "Coordinator",
        "reason": "Second-pass plan refinement based on Researcher findings",
        "audit_summary": "Researcher investigated 12 research gaps across extension, server, and dashboard. All gaps resolved with concrete findings.",
        "research_summary": "Detailed findings on ToolProvider interception, SessionInterceptRegistry persistence, spawn-agent-tool session_id minting, dashboard section patterns, server event types, and transparent session injection strategy.",
        "constraints": [
          "Do not implement code",
          "Only rewrite plan steps",
          "Use memory_steps replace action"
        ],
        "acceptance_criteria": [
          "All steps have concrete file paths and function signatures",
          "No RESEARCH NEEDED markers remain",
          "Steps incorporate transparent session injection finding",
          "Each step has clear acceptance criteria"
        ],
        "run_id": "run_sess_mlplcxmq_d0affb2c"
      },
      "completed_at": "2026-02-16T20:04:17.834Z",
      "summary": "Second-pass Architect refinement complete. Rewrote plan from 34 steps to 26 steps across 7 phases:\\n\\nPhase 1: Session Types & Registry (3 steps) ‚Äî session-types.ts, SessionInterceptRegistry class with workspaceState persistence, extension.ts wiring\\nPhase 2: Session Token Protocol (3 steps) ‚Äî spawn-agent-tool session_id minting, ToolProvider transparent session detection via _session_id meta-field, server audit\\nPhase 3: Tool Response Interception (3 steps) ‚Äî interceptor module with stop (3-level escalation) + inject delivery, ToolProvider wiring, hub propagation\\nPhase 4: Extension Panel UI (4 steps) ‚Äî sessions-section.ts, dashboard chain wiring, message handlers, real-time refresh\\nPhase 5: Server-Side Audit & Recovery (2 steps) ‚Äî 3 new event types, orphaned session detection\\nPhase 6: Agent Instructions (3 steps) ‚Äî new instructions file, update recovery/handoff docs, update agent.md files\\nPhase 7: Testing & Integration (7 steps) ‚Äî 4 test suites, build verification, code review\\n\\nKey changes from first pass:\\n1. Eliminated 7 file modifications via transparent _session_id meta-field approach (no tool schema changes in package.json or handler files)\\n2. All RESEARCH NEEDED markers replaced with concrete signatures, patterns, and insertion points from Researcher findings\\n3. Every step has acceptance criteria and line-count targets\\n4. Updated architecture.json and goals/success_criteria\\n\\nNew files: 9 (4 source + 1 instruction + 4 test files)\\nModified files: 17\\nRecommended next: Executor\"",
      "artifacts": []
    }
  ],
  "lineage": [
    {
      "timestamp": "2026-02-16T19:41:41.655Z",
      "from_agent": "Architect",
      "to_agent": "Coordinator",
      "reason": "First-pass plan complete with 35 steps across 9 phases. 10 research gaps identified for Researcher to investigate before second-pass refinement. Key files: ToolProvider.ts dispatch pattern, active-run-registry API, spawn-agent-tool enrichment flow, DashboardViewProvider section pattern, server memory_agent handler."
    },
    {
      "timestamp": "2026-02-16T19:51:17.558Z",
      "from_agent": "Researcher",
      "to_agent": "Coordinator",
      "reason": "All 12 research gaps resolved with exact interfaces, function signatures, patterns, and design recommendations. Research stored in codebase-investigation.md and research.json. Recommend Architect for second-pass plan refinement using these findings."
    },
    {
      "timestamp": "2026-02-16T20:04:03.844Z",
      "from_agent": "Architect",
      "to_agent": "Coordinator",
      "reason": "Second-pass plan refinement complete. 26 concrete steps across 7 phases with full implementation detail from Researcher findings. Key architectural change: transparent session detection via _session_id meta-field eliminates tool schema changes (removed 7 file modifications). Ready for Executor implementation."
    },
    {
      "timestamp": "2026-02-16T20:04:56.716Z",
      "from_agent": "Coordinator",
      "to_agent": "Coordinator",
      "reason": "Planning complete (Architect‚ÜíResearcher‚ÜíArchitect loop finished). Plan refined to 24 steps across 7 phases. Ready for Executor implementation."
    }
  ],
  "steps": [
    {
      "phase": "Phase 1: Session Types & Registry (Extension-Side)",
      "task": "Create session-types.ts in vscode-extension/src/chat/orchestration/session-types.ts ‚Äî Define all session-related types: SessionStatus ('active'|'stopping'|'stopped'|'completed'), SessionTripleKey {workspaceId, planId, sessionId}, StopEscalationLevel (1|2|3), InterruptDirective {requestedAt, escalationLevel, reason?}, InjectPayload {text, queuedAt}, LastToolCallInfo {toolName, timestamp, callCount}, SessionEntry {sessionId, workspaceId, planId, agentType, parentSessionId?, startedAt, status, lastToolCall?, interruptDirective?, injectQueue, stopEscalationCount}, SerializedRegistry {version: 1, sessions: Record<string, SessionEntry>}.",
      "type": "code",
      "status": "pending",
      "notes": "TYPES ONLY ‚Äî no runtime code. Follow naming conventions from active-run-registry.ts (ActiveRunRecord, LaneState). The parentSessionId field enables hub propagation (Phase 3 Step 9). SerializedRegistry is the persistence format for workspaceState. File should be <80 lines.\n\nAcceptance: All types exported. No runtime code. Compiles cleanly. Naming consistent with existing orchestration types.",
      "assignee": "Executor",
      "index": 0
    },
    {
      "phase": "Phase 1: Session Types & Registry (Extension-Side)",
      "task": "Create SessionInterceptRegistry class in vscode-extension/src/chat/orchestration/session-intercept-registry.ts ‚Äî Map<string, SessionEntry> keyed by tripleKey '${workspaceId}::${planId}::${sessionId}' (same pattern as active-run-registry lanes Map keyed by '${workspace_id}::${plan_id}'). Persistence via vscode.Memento (context.workspaceState) ‚Äî persist() on every mutation, restore() on activation. API: register(), get(), getBySessionId(), getByPlan(), markStopping(), markCompleted(), listActive(), queueInterrupt(), dequeueInterrupt(), incrementEscalation(), queueInject(), dequeueAllInjects(), recordToolCall(), pruneCompleted(). Expose onDidChange event via vscode.EventEmitter<void> for dashboard subscriptions.",
      "type": "code",
      "status": "pending",
      "notes": "CRITICAL: active-run-registry.ts has NO persistence (in-memory only). This registry MUST persist to context.workspaceState to survive extension reloads. Use storage.get<SerializedRegistry>(STORAGE_KEY) and storage.update(STORAGE_KEY, serialized) pattern.\n\nKey implementation details:\n- Constructor takes vscode.Memento (context.workspaceState)\n- static STORAGE_KEY = 'sessionInterceptRegistry'\n- tripleKey() helper: `${workspaceId}::${planId}::${sessionId}`\n- getBySessionId(sessionId): scans all entries (for ToolProvider which only has sessionId from _session_id meta-field)\n- restore(): deserialize from storage, prune entries older than 24h\n- persist(): serialize Map to JSON, write to storage ‚Äî call after EVERY mutation\n- onDidChange fires after every mutation (DashboardViewProvider subscribes for refresh)\n- register() initializes status='active', injectQueue=[], stopEscalationCount=0\n- incrementEscalation() returns min(current+1, 3) as StopEscalationLevel\n\nKeep under 280 lines. Follow class pattern (unlike active-run-registry which uses module-level functions) because constructor needs Memento reference.\n\nAcceptance: All methods implemented. Persistence round-trips correctly (register ‚Üí persist ‚Üí restore = same data). onDidChange fires on every mutation. getBySessionId lookup works. File ‚â§280 lines.",
      "assignee": "Executor",
      "index": 1
    },
    {
      "phase": "Phase 1: Session Types & Registry (Extension-Side)",
      "task": "Wire SessionInterceptRegistry into extension activation in vscode-extension/src/extension.ts ‚Äî Add module-level singleton 'let sessionInterceptRegistry: SessionInterceptRegistry | null = null' alongside existing singletons (toolProvider, dashboardProvider, etc. at lines ~10-20). In initializeChatIntegration() (line ~355), after McpBridge creation and before ToolProvider creation: instantiate registry with context.workspaceState, call restore(). Pass registry to ToolProvider constructor (modifies signature). Set registry on DashboardViewProvider via setter. Push registry disposal to context.subscriptions.",
      "type": "code",
      "status": "pending",
      "notes": "From Gap 11 findings: extension.ts uses module-level 'let' singletons (not DI container). initializeChatIntegration(context, config, dataRoot, options?) is the function that creates ToolProvider at line ~366: 'toolProvider = new ToolProvider(mcpBridge)'.\n\nExact insertion order in initializeChatIntegration:\n1. sessionInterceptRegistry = new SessionInterceptRegistry(context.workspaceState);\n2. sessionInterceptRegistry.restore();\n3. toolProvider = new ToolProvider(mcpBridge, sessionInterceptRegistry);  // modified signature\n4. dashboardProvider.setSessionRegistry(sessionInterceptRegistry);  // new setter method\n\nAlso update ToolContext in vscode-extension/src/chat/tools/types.ts:\n- Add: sessionRegistry?: SessionInterceptRegistry\n- ToolProvider constructor sets this on the shared ctx object\n\nAcceptance: Registry instantiated before ToolProvider. restore() called at activation. ToolProvider and DashboardViewProvider both have registry reference. Extension compiles. Non-chat activation paths unaffected.",
      "assignee": "Executor",
      "index": 2
    },
    {
      "phase": "Phase 2: Session Token Protocol (Spawn & ToolProvider)",
      "task": "Modify spawn-agent-tool.ts to mint session_id and register session ‚Äî In handleSpawnAgentTool (vscode-extension/src/chat/tools/spawn-agent-tool.ts, 376 lines), after resolving workspace_id and plan_id (line ~215), mint session_id: 'sess_' + Date.now().toString(36) + '_' + crypto.randomUUID().slice(0,8). Register session in ctx.sessionRegistry if available. Inject session_id into enriched_prompt: (a) add 'Session: ${sessionId}' line in the '--- CONTEXT ---' block after Plan line (line ~255), (b) add SESSION TRACKING meta-instruction block telling subagent to include '_session_id' in every tool call, (c) add session_id to returned prep_config output.",
      "type": "code",
      "status": "pending",
      "notes": "From Gap 3 findings: enrichment order is CONTEXT block ‚Üí scope_boundaries ‚Üí anti_spawning ‚Üí git_stability_guard ‚Üí original_prompt. session_id injection goes in the CONTEXT block and as a new block before scope_boundaries.\n\nSession registration call:\nctx.sessionRegistry?.register({\n  sessionId,\n  workspaceId: input.workspace_id,\n  planId: input.plan_id,\n  agentType: input.agent_name,\n  parentSessionId: undefined, // TODO: detect hub session\n  startedAt: new Date().toISOString()\n});\n\nSESSION TRACKING block to inject into prompt:\n```\nSESSION TRACKING (REQUIRED):\nInclude \"_session_id\": \"${sessionId}\" in every tool call input.\nThis enables the session management system to track your activity.\nDo not omit this field from any tool call.\n```\n\nUpdate prep_config return to include session_id field.\n\nAcceptance: Every spawn prep mints unique session_id. Session registered in registry. session_id in enriched_prompt CONTEXT block + meta-instruction. prep_config output includes session_id. Non-spawn tool calls unaffected.",
      "assignee": "Executor",
      "index": 3
    },
    {
      "phase": "Phase 2: Session Token Protocol (Spawn & ToolProvider)",
      "task": "Update ToolProvider to accept SessionInterceptRegistry and add transparent session detection in invoke lambdas ‚Äî In vscode-extension/src/chat/ToolProvider.ts (~130 lines), update constructor to accept optional SessionInterceptRegistry. Store as instance field. Update ctx object construction to include sessionRegistry. In registerTools() (line ~56), wrap each of the 6 invoke lambdas with session detection: read '_session_id' from options.input, strip it before forwarding to handler, store for post-handler interception routing. After handler returns result, if _session_id was present and session exists in registry, route through interceptToolResponse() (imported from tool-response-interceptor.ts, created in Phase 3). If no _session_id, return handler result unchanged.",
      "type": "code",
      "status": "pending",
      "notes": "CRITICAL DESIGN DECISION: Do NOT add session_id/is_subagent to tool schemas in package.json (Gap 12 finding). Session detection is transparent via _session_id meta-field included by subagents per their enriched prompt instruction.\n\nFrom Gap 1 findings: Each invoke lambda currently:\n```typescript\ninvoke: (options, token) => handleAgentTool(options as never, token, this.ctx)\n```\n\nRefactored pattern (DRY ‚Äî extract helper):\n```typescript\nprivate async wrapInvoke<T>(\n  handler: (options: any, token: any, ctx: ToolContext) => Promise<vscode.LanguageModelToolResult>,\n  options: vscode.LanguageModelToolInvocationOptions<T>,\n  token: vscode.CancellationToken,\n  toolName: string\n): Promise<vscode.LanguageModelToolResult> {\n  const input = options.input as Record<string, unknown>;\n  const sessionId = typeof input._session_id === 'string' ? input._session_id : undefined;\n  if (sessionId) delete input._session_id; // strip meta-field\n  \n  const result = await handler(options as never, token, this.ctx);\n  \n  if (sessionId && this.sessionRegistry) {\n    return interceptToolResponse(this.sessionRegistry, sessionId, toolName, result);\n  }\n  return result;\n}\n```\n\nThen each registration becomes:\n```typescript\nvscode.lm.registerTool('memory_agent', {\n  invoke: (options, token) => this.wrapInvoke(handleAgentTool, options, token, 'memory_agent')\n})\n```\n\nNote: interceptToolResponse import will fail until Phase 3 Step 6 creates the module. Executor should add a TODO comment or create a stub that passes through. Complete wiring in Step 8.\n\nAcceptance: ToolProvider accepts optional registry. wrapInvoke helper extracts _session_id, strips it, runs handler, routes through interceptor if session tracked. Non-subagent calls (no _session_id) unchanged. File stays under 180 lines.",
      "assignee": "Executor",
      "index": 4
    },
    {
      "phase": "Phase 2: Session Token Protocol (Spawn & ToolProvider)",
      "task": "Add session_id awareness to server-side memory_agent init ‚Äî In server/src/tools/consolidated/memory_agent.ts (389 lines), in the init case handler (line ~104), after initialiseAgent() returns, if params.context?.session_id exists, include it in the emitted agent_session_started event data. No structural changes ‚Äî the session_id is already stored in AgentSession.context (initialiseAgent stores arbitrary context). This step ensures the server-side audit trail includes session_id for subagent sessions.",
      "type": "code",
      "status": "pending",
      "notes": "From Gap 8 findings: init delegates to handoffTools.initialiseAgent(). Session is created with store.generateSessionId() ‚Üí AgentSession { session_id, agent_type, started_at, context }. The context object already stores arbitrary data from params.context.\n\nThe extension passes session_id in context when calling memory_agent init:\nparams.context = { ...originalContext, session_id: mintedSessionId }\n\nServer change: In the init handler, after initialiseAgent() returns:\n```typescript\nif (result.data?.session?.context?.session_id) {\n  // Include extension-minted session_id in event for audit trail\n  await events.agentSessionStarted(\n    workspace_id, plan_id, agent_type,\n    result.data.session.session_id,\n    { extension_session_id: result.data.session.context.session_id }\n  );\n}\n```\n\nPurely additive ‚Äî no changes to init response shape or agent session creation. Server compiles without new dependencies.\n\nAcceptance: session_id from extension context appears in agent_session_started event data. No breaking changes. Server builds clean.",
      "assignee": "Executor",
      "index": 5
    },
    {
      "phase": "Phase 3: Tool Response Interception (Stop & Inject)",
      "task": "Create tool-response-interceptor.ts in vscode-extension/src/chat/orchestration/tool-response-interceptor.ts ‚Äî Implement interceptToolResponse(registry, sessionId, toolName, originalResult) function: (1) Look up session via registry.getBySessionId(), (2) Record tool call via registry.recordToolCall(), (3) Check for stop directive (takes precedence over inject), (4) If stopping: generate directive text based on escalation level (L1 = directive + original response, L2 = directive text only, L3 = error response), increment escalation, (5) If no stop: check inject queue, dequeue all, prepend concatenated inject text to response, (6) Return modified LanguageModelToolResult. Also implement validateInjectText(text): enforce 500 char limit, strip tool-call-like JSON patterns, block system-prompt-like patterns.",
      "type": "code",
      "status": "pending",
      "notes": "Stop directive text templates:\n\nLEVEL 1: '‚ö†Ô∏è SESSION STOP REQUESTED\\nThe user has requested that you stop your current work.\\nPlease call memory_agent(action: handoff) to Coordinator with reason \"User requested stop\", then call memory_agent(action: complete).\\nComplete your current tool call normally, then stop.\\n\\n--- ORIGINAL RESPONSE ---\\n' + originalText\n\nLEVEL 2: 'üõë SESSION STOP ‚Äî IMMEDIATE\\nYou MUST stop immediately. Do NOT continue with any more work.\\nCall memory_agent(action: handoff) to Coordinator with reason \"User forced stop\", then memory_agent(action: complete).\\nDo not process any more steps.'\n\nLEVEL 3: Return error-like response: '‚ùå SESSION TERMINATED\\nThis session has been terminated by the user. All further tool calls will return this error. Session ID: ${sessionId}'\nAlso mark session as 'stopped' in registry.\n\nInject prepend format:\n'üìù USER GUIDANCE (injected by user):\\n${injectTexts.join(\"\\n\")}\\n\\n--- TOOL RESPONSE ---\\n' + originalText\n\nvalidateInjectText rules:\n- Max 500 chars (truncate with warning)\n- Strip patterns matching JSON tool-call syntax: /{\"action\":|{\"tool\":/\n- Strip patterns matching system prompt manipulation: /you are now|ignore previous|system:/i\n- Return { valid: boolean, sanitized: string, warnings: string[] }\n\nResponse creation (from Gap 1 findings):\nnew vscode.LanguageModelToolResult([new vscode.LanguageModelTextPart(modifiedText)])\n\nKeep under 180 lines total.\n\nAcceptance: interceptToolResponse handles all three paths (stop/inject/pass-through). Stop escalation works (L1‚ÜíL2‚ÜíL3 on consecutive calls). Inject prepends correctly. validateInjectText blocks dangerous patterns. File ‚â§180 lines.",
      "assignee": "Executor",
      "index": 6
    },
    {
      "phase": "Phase 3: Tool Response Interception (Stop & Inject)",
      "task": "Complete ToolProvider interception wiring ‚Äî If Step 4 used a stub/TODO for interceptToolResponse import, replace with real import from tool-response-interceptor.ts. Verify all 6 invoke lambdas (memory_workspace, memory_agent, memory_plan, memory_steps, memory_context, memory_spawn_agent) go through wrapInvoke. Add special handling for memory_spawn_agent: after spawn prep returns, if session was just registered, the _session_id in the spawn response should NOT trigger interception (spawn prep itself is from the hub, not the subagent). Verify lastToolCall tracking works end-to-end.",
      "type": "code",
      "status": "pending",
      "notes": "This step connects Phase 2's ToolProvider skeleton with Phase 3's interceptor module.\n\nSpecial case for memory_spawn_agent: The hub agent calling spawn_agent does NOT include _session_id (it's not a subagent). The _session_id is only included by the subagent in its subsequent tool calls. So no special handling is needed ‚Äî the hub's spawn call won't have _session_id and will pass through normally.\n\nVerify that the wrapInvoke pattern correctly:\n1. Extracts _session_id from input\n2. Strips it before handler sees it (mutation-safe: Object.assign or spread if needed)\n3. Passes original result to interceptor\n4. Returns interceptor result to LM\n\nAcceptance: All 6 tools route through wrapInvoke. Import of interceptToolResponse resolves. Memory_spawn_agent calls from hub agents pass through unchanged. Extension compiles cleanly.",
      "assignee": "Executor",
      "index": 7
    },
    {
      "phase": "Phase 3: Tool Response Interception (Stop & Inject)",
      "task": "Implement hub-agent stop propagation ‚Äî When a child session is marked stopped/completed via stop directive (Level 3 or agent compliance), queue a notification for the parent session so the hub agent learns the subagent was interrupted on its next tool call. In SessionInterceptRegistry: when markCompleted() is called with a stopReason, look up parentSessionId; if parent session exists and is active, queue a special inject-like notification. In tool-response-interceptor.ts: handle 'notification' type payload (not a full stop, just informational text prepended to response).",
      "type": "code",
      "status": "pending",
      "notes": "Propagation flow:\n1. Child session receives Level 3 stop ‚Üí interceptor calls registry.markCompleted(childKey, 'user_stopped')\n2. markCompleted checks parentSessionId on the child entry\n3. If parent session exists and status='active', queue a notification:\n   registry.queueInject(parentWsId, parentPlanId, parentSessionId, \n     '‚ö†Ô∏è SUBAGENT INTERRUPTED: Agent \"${childAgentType}\" (session ${childSessionId}) was stopped by the user. Check plan state and decide whether to re-attempt or proceed differently.')\n4. Hub agent's next tool call picks up this inject text via normal inject delivery path\n\nFor parentSessionId tracking: The spawn-agent-tool needs to know the hub's session. Options:\n- Hub agent includes its own session_id when calling memory_spawn_agent\n- The spawn tool checks if the current call has _session_id (hub's session)\n\nMinimal approach for v1: parentSessionId is tracked if available, propagation is best-effort. If parentSessionId is null, skip propagation.\n\nAcceptance: When a child stops, parent receives notification inject on next tool call. If no parentSessionId, gracefully skips. No errors on missing parent session.",
      "assignee": "Executor",
      "index": 8
    },
    {
      "phase": "Phase 4: Extension Panel UI (Sessions Section)",
      "task": "Create sessions-section.ts in vscode-extension/src/providers/dashboard-webview/sessions-section.ts ‚Äî Export getSessionsSectionHtml(iconSvgs): string and getSessionsClientHelpers(): string. HTML: collapsible section (id='widget-sessions') with session list container, stop button, inject text input + inject button. Follow exact pattern from instructions-section.ts and skills-section.ts.",
      "type": "code",
      "status": "pending",
      "notes": "From Gap 6 findings ‚Äî exact pattern to follow:\n\nHTML structure:\n```html\n<section class=\"collapsible collapsed\" id=\"widget-sessions\">\n  <button class=\"collapsible-header\" data-action=\"toggle-collapse\" data-target=\"widget-sessions\">\n    <span class=\"chevron\">></span>\n    <h3>Active Sessions</h3>\n  </button>\n  <div class=\"collapsible-content\">\n    <div class=\"widget-body\">\n      <div class=\"sessions-header\">\n        <button class=\"btn btn-small\" data-action=\"refresh-sessions\" title=\"Refresh session list\">\n          ${iconSvgs.syncHistory} Refresh\n        </button>\n      </div>\n      <div class=\"sessions-list\" id=\"sessionsList\">\n        <div class=\"empty-state\">No active sessions</div>\n      </div>\n      <div class=\"sessions-controls\" id=\"sessionsControls\" style=\"display:none\">\n        <button class=\"btn btn-small\" data-action=\"stop-session\" id=\"stopSessionBtn\" disabled>Stop</button>\n        <div class=\"inject-row\">\n          <input type=\"text\" id=\"injectText\" placeholder=\"Inject guidance...\" maxlength=\"500\" />\n          <button class=\"btn btn-small\" data-action=\"inject-session\" id=\"injectSessionBtn\" disabled>Inject</button>\n        </div>\n      </div>\n    </div>\n  </div>\n</section>\n```\n\nClient helpers (getSessionsClientHelpers()):\n- renderSessionsList(sessions): HTML for session items (agentType, planId, elapsed time, lastToolCall, status badge)\n- updateSessionsList(sessions): Update DOM innerHTML of #sessionsList\n- requestSessionsList(): vscode.postMessage({ type: 'getSessions' })\n- handleSessionSelect(sessionKey): Single-select highlighting, enable/disable controls\n- handleStopSession(): Post { type: 'stopSession', data: { sessionKey } }\n- handleInjectSession(): Post { type: 'injectSession', data: { sessionKey, text } }\n\nCSS classes: Use existing conventions ‚Äî badge-ok for active, badge badge-warn for stopping, empty-state for no sessions. data-action for event delegation.\n\nKeep under 200 lines.\n\nAcceptance: Exports two functions matching section pattern. HTML renders correctly. Client helpers handle select/stop/inject. File ‚â§200 lines.",
      "assignee": "Executor",
      "index": 9
    },
    {
      "phase": "Phase 4: Extension Panel UI (Sessions Section)",
      "task": "Wire sessions section into dashboard assembly chain ‚Äî Import getSessionsSectionHtml in vscode-extension/src/providers/dashboard-webview/sections.ts and embed after skills/instructions sections in getConnectedDashboardHtml(). Import getSessionsClientHelpers in vscode-extension/src/providers/dashboard-webview/client-script.ts and embed in getClientScript(). Add message handling cases in vscode-extension/src/providers/DashboardViewProvider.ts resolveWebviewView switch block for 'getSessions', 'stopSession', 'injectSession'.",
      "type": "code",
      "status": "pending",
      "notes": "From Gap 5 findings ‚Äî assembly chain:\n1. DashboardViewProvider._getHtmlForWebview() ‚Üí getWebviewHtml(options) [dashboard-webview/index.ts]\n2. getWebviewHtml ‚Üí getClientScript(params) [client-script.ts]\n3. getClientScript ‚Üí getConnectedDashboardHtml(iconSvgs, apiPort, workspaceName) [sections.ts]\n4. getConnectedDashboardHtml embeds getSessionsSectionHtml(iconSvgs)\n5. getClientScript embeds getSessionsClientHelpers()\n\nIn sections.ts: Add import and call getSessionsSectionHtml(iconSvgs) after existing sections.\nIn client-script.ts: Add import and embed getSessionsClientHelpers() in the client JS.\nIn DashboardViewProvider.resolveWebviewView (line ~154), add cases:\n- case 'getSessions': handleGetSessions(this, this.sessionRegistry); break;\n- case 'stopSession': handleStopSession(this, this.sessionRegistry, message.data); break;\n- case 'injectSession': handleInjectSession(this, this.sessionRegistry, message.data); break;\n\nAlso add to DashboardViewProvider:\n- private sessionRegistry?: SessionInterceptRegistry\n- setSessionRegistry(registry: SessionInterceptRegistry): void { this.sessionRegistry = registry; }\n- In resolveWebviewView, subscribe to registry.onDidChange ‚Üí post updated session list\n\nAcceptance: Sessions section visible in dashboard. Message handlers connected. Selecting a session, clicking stop, and injecting text all send correct messages. Compiles cleanly.",
      "assignee": "Executor",
      "index": 10
    },
    {
      "phase": "Phase 4: Extension Panel UI (Sessions Section)",
      "task": "Add session message handlers in vscode-extension/src/providers/dashboard-webview/dashboard-message-handlers.ts ‚Äî Add handleGetSessions(poster, registry), handleStopSession(poster, registry, data), handleInjectSession(poster, registry, data). Follow existing handler pattern (handleGetSkills, handleDeploySkill) but with SessionInterceptRegistry parameter.",
      "type": "code",
      "status": "pending",
      "notes": "From Gap 7 findings: MessagePoster interface { postMessage(msg) }. Handlers receive poster + optional typed data.\n\nNew handlers:\n```typescript\nexport function handleGetSessions(\n  poster: MessagePoster,\n  registry: SessionInterceptRegistry | undefined\n): void {\n  if (!registry) {\n    poster.postMessage({ type: 'sessionsList', data: { sessions: [] } });\n    return;\n  }\n  const sessions = registry.listActive();\n  poster.postMessage({ type: 'sessionsList', data: { sessions } });\n}\n\nexport function handleStopSession(\n  poster: MessagePoster,\n  registry: SessionInterceptRegistry | undefined,\n  data: { sessionKey: string }\n): void {\n  if (!registry) return;\n  // Parse tripleKey: 'workspaceId::planId::sessionId'\n  const [workspaceId, planId, sessionId] = data.sessionKey.split('::');\n  const queued = registry.queueInterrupt(workspaceId, planId, sessionId);\n  poster.postMessage({ type: 'sessionStopResult', data: { success: queued, sessionKey: data.sessionKey } });\n}\n\nexport function handleInjectSession(\n  poster: MessagePoster,\n  registry: SessionInterceptRegistry | undefined,\n  data: { sessionKey: string; text: string }\n): void {\n  if (!registry) return;\n  const [workspaceId, planId, sessionId] = data.sessionKey.split('::');\n  const queued = registry.queueInject(workspaceId, planId, sessionId, data.text);\n  poster.postMessage({ type: 'sessionInjectResult', data: { success: queued, sessionKey: data.sessionKey } });\n}\n```\n\nAcceptance: Three handlers implemented. Each posts result back to webview. Graceful fallback if registry undefined. Handler file stays under 300 lines total.",
      "assignee": "Executor",
      "index": 11
    },
    {
      "phase": "Phase 4: Extension Panel UI (Sessions Section)",
      "task": "Implement real-time session list refresh ‚Äî In DashboardViewProvider, subscribe to sessionInterceptRegistry.onDidChange in resolveWebviewView. On change, post updated session list to webview via poster.postMessage({ type: 'sessionsList', data: { sessions } }). Also add client-side requestSessionsList() call on panel mount (initial load) and data-action='refresh-sessions' click handler.",
      "type": "code",
      "status": "pending",
      "notes": "Two refresh mechanisms:\n1. Event-driven: DashboardViewProvider subscribes to registry.onDidChange ‚Üí pushes updated list. This fires on every registry mutation (register, stop, inject, tool call record).\n2. Manual: User clicks Refresh button ‚Üí data-action='refresh-sessions' ‚Üí requestSessionsList() ‚Üí getSessions message ‚Üí handler ‚Üí response.\n\nIn DashboardViewProvider.resolveWebviewView():\n```typescript\nif (this.sessionRegistry) {\n  const changeDisposable = this.sessionRegistry.onDidChange(() => {\n    handleGetSessions(this, this.sessionRegistry);\n  });\n  // Push to webview disposables for cleanup\n}\n```\n\nFollow same polling pattern as existing skills/instructions sections for initial load.\n\nAcceptance: Session list updates in real-time when registry changes. Manual refresh button works. No memory leaks (disposable cleaned up on webview dispose).",
      "assignee": "Executor",
      "index": 12
    },
    {
      "phase": "Phase 5: Server-Side Audit & Recovery",
      "task": "Add 3 new session lifecycle event types to server/src/events/event-emitter.ts ‚Äî Add 'session_interrupted', 'session_injected', 'session_stop_escalated' to EventType union. Add convenience emitter functions: events.sessionInterrupted(workspaceId, planId, sessionId, escalationLevel), events.sessionInjected(workspaceId, planId, sessionId, injectTextPreview), events.sessionStopEscalated(workspaceId, planId, sessionId, fromLevel, toLevel).",
      "type": "code",
      "status": "pending",
      "notes": "From Gap 9 findings: 11 event types exist. EventType is a string union type. Events stored as individual JSON files in data/events/ + appended to events.log.\n\nExisting convenience emitters pattern:\n```typescript\nevents.agentSessionStarted(workspaceId, planId, agentType, sessionId)\nevents.agentSessionCompleted(workspaceId, planId, agentType, summary, artifacts)\n```\n\nNew convenience emitters:\n```typescript\nexport async function sessionInterrupted(\n  workspaceId: string, planId: string, sessionId: string, \n  escalationLevel: number, reason?: string\n): Promise<void> {\n  await emitEvent({ type: 'session_interrupted', workspace_id: workspaceId,\n    plan_id: planId, data: { session_id: sessionId, escalation_level: escalationLevel, reason } });\n}\n\nexport async function sessionInjected(\n  workspaceId: string, planId: string, sessionId: string,\n  textPreview: string\n): Promise<void> {\n  await emitEvent({ type: 'session_injected', workspace_id: workspaceId,\n    plan_id: planId, data: { session_id: sessionId, text_preview: textPreview.slice(0, 100) } });\n}\n```\n\nExtension calls these via McpBridge when interceptor applies stop/inject. Could also emit directly from tool-response-interceptor if McpBridge is available in context.\n\nAcceptance: 3 new event types compile. Convenience emitters follow existing pattern. Server builds clean.",
      "assignee": "Executor",
      "index": 13
    },
    {
      "phase": "Phase 5: Server-Side Audit & Recovery",
      "task": "Implement orphaned session detection ‚Äî On hub agent memory_agent(init), the extension-side agent-tool handler checks SessionInterceptRegistry for sessions matching workspace_id + plan_id that are still 'active' but have no recent tool calls (stale). Return structured orphaned_sessions warnings in the tool response alongside the normal init result. Also add cleanup: when hub re-inits, offer to mark orphaned sessions as completed.",
      "type": "code",
      "status": "pending",
      "notes": "Detection happens in the extension, not server. In vscode-extension/src/chat/tools/agent-tool.ts handleAgentTool():\n\nWhen action='init' and the server response succeeds:\n1. Check ctx.sessionRegistry for sessions matching workspace_id + plan_id\n2. Filter to status='active' entries with lastToolCall older than 10 minutes (or no lastToolCall)\n3. Build orphaned_sessions array: [{ sessionId, agentType, startedAt, lastToolCall }]\n4. If orphaned_sessions.length > 0, append to the result JSON:\n   result.data.orphaned_sessions = orphanedSessions\n   result.data.orphaned_session_warning = 'Found N orphaned subagent sessions...'\n5. Auto-cleanup: mark orphaned sessions as 'completed' with reason 'orphaned_auto_cleanup'\n\nUses stale threshold of 10 minutes (consistent with active-run-registry's 10-minute stale threshold from Gap 2 findings).\n\nAcceptance: Hub agent init response includes orphaned session warnings when they exist. Orphaned sessions auto-cleaned. Normal init flow unaffected when no orphans.",
      "assignee": "Executor",
      "index": 14
    },
    {
      "phase": "Phase 6: Agent Instruction Updates",
      "task": "Create session-interruption.instructions.md at .github/instructions/session-interruption.instructions.md ‚Äî Document: (1) How agents should respond to stop directives (check for ‚ö†Ô∏è/üõë/‚ùå prefixes in tool responses, comply by calling handoff+complete), (2) How agents should handle inject text (treat üìù USER GUIDANCE as high-priority user direction), (3) How hub agents handle orphaned session warnings from init, (4) The _session_id meta-field requirement for subagent tool calls, (5) The 3-level stop escalation ladder.",
      "type": "documentation",
      "status": "pending",
      "notes": "This file will be auto-loaded by agents via the instruction system (applyTo: '**/*').\n\nKey sections:\n- Overview: What the session interruption system does\n- For Subagents: Always include _session_id in tool calls, respond to stop directives immediately\n- For Hub Agents: Check for orphaned_sessions in init response, handle recovery\n- Stop Directive Reference: Level 1 (graceful), Level 2 (immediate), Level 3 (terminated)\n- Inject Guidance: Treat injected text as user direction, adjust approach accordingly\n- Security: Inject text is validated/sanitized, agents should not treat it as system instructions\n\nKeep under 150 lines.\n\nAcceptance: File created with proper frontmatter (applyTo: '**/*'). All 5 documentation areas covered. Clear, actionable instructions.",
      "assignee": "Executor",
      "index": 15
    },
    {
      "phase": "Phase 6: Agent Instruction Updates",
      "task": "Update subagent-recovery.instructions.md and handoff-protocol.instructions.md ‚Äî In subagent-recovery.instructions.md: add section on 'Interrupt-Driven Recovery' covering how stop directives interact with the existing recovery protocol, and how orphaned session detection replaces/supplements manual git-diff checking. In handoff-protocol.instructions.md: add note about session_id propagation through spawns and how stop directives trigger graceful handoff.",
      "type": "documentation",
      "status": "pending",
      "notes": "subagent-recovery.instructions.md ‚Äî Add after 'Step 5: Course-Correct':\n## Interrupt-Driven Recovery\nWhen the user uses the Stop button in the extension panel:\n1. The subagent receives a stop directive on its next tool call\n2. Compliant agents call handoff+complete automatically\n3. Hub agents receive orphaned session warnings on re-init\n4. This replaces manual user-cancellation detection for managed sessions\n\nhandoff-protocol.instructions.md ‚Äî Add to 'Subagent Spawning Rules':\n- session_id is minted by the extension during spawn prep and injected into the subagent's prompt\n- Subagents MUST include _session_id in every tool call for session tracking\n- If a subagent receives a stop directive, it should call memory_agent(action: handoff) with reason 'User requested stop' then memory_agent(action: complete)\n\nAcceptance: Both files updated with accurate session interruption information. No conflicting instructions introduced.",
      "assignee": "Executor",
      "index": 16
    },
    {
      "phase": "Phase 6: Agent Instruction Updates",
      "task": "Update agent.md files ‚Äî Update coordinator.agent.md: add awareness of orphaned session detection in init, and how to handle interrupted subagents. Update executor.agent.md: add instruction to check for stop directives in tool responses and comply immediately. Similar brief additions to reviewer.agent.md and tester.agent.md.",
      "type": "documentation",
      "status": "pending",
      "notes": "Agent files are in Project-Memory-MCP/agents/.\n\nCoordinator additions:\n- On re-init, check for orphaned_sessions in init response\n- If orphaned sessions found, follow recovery protocol\n- After subagent returns with 'User requested stop' reason, assess plan state before spawning next agent\n\nExecutor/Reviewer/Tester additions:\n- 'If you receive a stop directive (‚ö†Ô∏è SESSION STOP or üõë SESSION STOP ‚Äî IMMEDIATE) in any tool response, immediately call memory_agent(action: handoff) with reason \"User requested stop\" and then memory_agent(action: complete). Do not continue work.'\n- 'If you receive injected user guidance (üìù USER GUIDANCE), treat it as a high-priority direction and adjust your approach accordingly.'\n\nKeep additions brief ‚Äî 5-10 lines per file.\n\nAcceptance: All 4 agent files updated. Instructions are consistent with the stop/inject protocol. No contradictions with existing agent instructions.",
      "assignee": "Executor",
      "index": 17
    },
    {
      "phase": "Phase 7: Testing & Integration",
      "task": "Write unit tests for SessionInterceptRegistry ‚Äî Test file: vscode-extension/src/chat/orchestration/__tests__/session-intercept-registry.test.ts. Test cases: register/get/list lifecycle, triple-ID isolation (two sessions on same plan don't collide), persistence round-trip (register ‚Üí persist ‚Üí restore = same data), interrupt queue (queue/dequeue/escalation), inject queue (queue/dequeue-all), markStopping/markCompleted status transitions, onDidChange fires on every mutation, pruneCompleted removes old entries, getBySessionId lookup.",
      "type": "test",
      "status": "pending",
      "notes": "Mock vscode.Memento for persistence testing:\n```typescript\nclass MockMemento implements vscode.Memento {\n  private store = new Map<string, any>();\n  get<T>(key: string): T | undefined { return this.store.get(key); }\n  async update(key: string, value: any): Promise<void> { this.store.set(key, value); }\n  keys(): readonly string[] { return [...this.store.keys()]; }\n}\n```\n\nKey test scenarios:\n1. Register session ‚Üí get returns it ‚Üí listActive includes it\n2. Two sessions with same workspace+plan but different sessionId ‚Üí both accessible\n3. Register ‚Üí serialize ‚Üí new registry ‚Üí restore ‚Üí get returns same data\n4. queueInterrupt ‚Üí dequeueInterrupt returns directive ‚Üí second dequeue returns undefined\n5. incrementEscalation returns 1, then 2, then 3, then stays at 3\n6. queueInject √ó 3 ‚Üí dequeueAllInjects returns all 3 in FIFO order\n7. markCompleted ‚Üí listActive excludes it\n8. pruneCompleted with maxAge removes only old completed sessions\n\nAcceptance: All test cases pass. Tests run via npx vitest run. No flaky tests.",
      "assignee": "Tester",
      "index": 18
    },
    {
      "phase": "Phase 7: Testing & Integration",
      "task": "Write unit tests for tool-response-interceptor ‚Äî Test file: vscode-extension/src/chat/orchestration/__tests__/tool-response-interceptor.test.ts. Test cases: pass-through for unknown session, stop directive at each level (L1 includes original, L2 directive only, L3 error response), inject prepend (single and multiple), stop+inject precedence (stop wins), escalation increment on consecutive calls, validateInjectText (valid text, too long, dangerous patterns blocked).",
      "type": "test",
      "status": "pending",
      "notes": "Mock LanguageModelToolResult for testing:\n```typescript\nfunction mockResult(text: string): vscode.LanguageModelToolResult {\n  return new vscode.LanguageModelToolResult([\n    new vscode.LanguageModelTextPart(text)\n  ]);\n}\n```\n\nKey test scenarios:\n1. interceptToolResponse with unknown sessionId ‚Üí returns original result unchanged\n2. Session active, no stop/inject ‚Üí returns original (but records tool call)\n3. Session stopping, L1 ‚Üí result text starts with '‚ö†Ô∏è SESSION STOP' and includes original\n4. Same session, next call ‚Üí L2 text, no original response\n5. Same session, next call ‚Üí L3 error text, session marked stopped\n6. Session with inject queued ‚Üí result text starts with 'üìù USER GUIDANCE' and includes original\n7. Session with stop AND inject ‚Üí stop directive returned (inject ignored)\n8. validateInjectText('hello') ‚Üí valid\n9. validateInjectText('a'.repeat(600)) ‚Üí truncated to 500\n10. validateInjectText('{\"action\": \"delete\"}') ‚Üí sanitized\n\nAcceptance: All test cases pass. Stop escalation verified across 3 calls. Inject validation covers edge cases.",
      "assignee": "Tester",
      "index": 19
    },
    {
      "phase": "Phase 7: Testing & Integration",
      "task": "Write integration test for full stop flow ‚Äî Test file: vscode-extension/src/chat/orchestration/__tests__/session-stop-integration.test.ts. Scenario: Create registry ‚Üí register session ‚Üí queue interrupt ‚Üí call interceptToolResponse (simulating tool call from subagent) ‚Üí verify L1 directive in response ‚Üí call again ‚Üí verify L2 ‚Üí call again ‚Üí verify L3 + session marked stopped. Also test: hub propagation (child stop ‚Üí parent gets notification inject).",
      "type": "test",
      "status": "pending",
      "notes": "Integration test uses real SessionInterceptRegistry (with MockMemento) and real interceptToolResponse. No mocking of the interception logic.\n\nFlow:\n1. const registry = new SessionInterceptRegistry(new MockMemento());\n2. registry.register({ sessionId: 'sess_child', workspaceId: 'ws1', planId: 'plan1', agentType: 'Executor', parentSessionId: 'sess_hub', startedAt: ... });\n3. registry.register({ sessionId: 'sess_hub', workspaceId: 'ws1', planId: 'plan1', agentType: 'Coordinator', startedAt: ... });\n4. registry.queueInterrupt('ws1', 'plan1', 'sess_child');\n5. result1 = interceptToolResponse(registry, 'sess_child', 'memory_plan', mockResult('{...}'));\n6. Verify result1 contains L1 stop directive + original text\n7. result2 = interceptToolResponse(registry, 'sess_child', 'memory_steps', mockResult('{...}'));\n8. Verify result2 contains L2 stop directive, no original text\n9. result3 = interceptToolResponse(registry, 'sess_child', 'memory_agent', mockResult('{...}'));\n10. Verify result3 contains L3 error, session status='stopped'\n11. Verify parent 'sess_hub' has notification in inject queue\n\nAcceptance: Full escalation ladder works end-to-end. Hub propagation delivers notification. Persistence survives through the flow.",
      "assignee": "Tester",
      "index": 20
    },
    {
      "phase": "Phase 7: Testing & Integration",
      "task": "Write integration test for full inject flow ‚Äî Test file: vscode-extension/src/chat/orchestration/__tests__/session-inject-integration.test.ts. Scenario: Create registry ‚Üí register session ‚Üí queue 3 inject payloads ‚Üí call interceptToolResponse ‚Üí verify all 3 texts prepended in FIFO order ‚Üí call again ‚Üí verify no inject (queue drained). Also test: inject after validation (long text truncated, dangerous text sanitized).",
      "type": "test",
      "status": "pending",
      "notes": "Flow:\n1. Register session, queue 3 injects with different text\n2. First interceptToolResponse ‚Üí response contains all 3 inject texts concatenated + original\n3. Second interceptToolResponse ‚Üí response is just original (queue empty)\n4. Queue inject with 600-char text ‚Üí verify truncated to 500 in delivery\n5. Queue inject with '{\"action\": \"delete\"}' ‚Üí verify sanitized\n\nAcceptance: Multi-inject delivery works. Queue drains correctly. Validation applies before delivery.",
      "assignee": "Tester",
      "index": 21
    },
    {
      "phase": "Phase 7: Testing & Integration",
      "task": "Build verification ‚Äî Compile extension (npm run compile in vscode-extension/), compile server (npm run build in server/), run all extension tests (npx vitest run in vscode-extension/ if configured), run all server tests (npx vitest run in server/). Verify no regressions in existing functionality.",
      "type": "build",
      "status": "pending",
      "notes": "Build commands from workspace build scripts:\n- Extension: cd vscode-extension && npm run compile\n- Server: cd server && npm run build\n- Server tests: cd server && npx vitest run\n- Extension tests: cd vscode-extension && npx vitest run (or npm test if configured)\n\nKey regression checks:\n- All 6 existing tools still register and invoke correctly\n- Dashboard loads without errors\n- Extension activates without errors\n- Server starts and responds to tool calls\n- Non-subagent tool calls are completely unchanged (no _session_id = pass-through)\n\nAcceptance: All builds succeed. All existing tests pass. No TypeScript compilation errors.",
      "assignee": "Reviewer",
      "index": 22
    },
    {
      "phase": "Phase 7: Testing & Integration",
      "task": "Code review ‚Äî Review all new and modified files for: consistent patterns with existing code, no monolithic files >300 lines, proper TypeScript types (no 'any' leaks), security boundaries (inject sanitization covers prompt injection), backward compatibility (_session_id gating ensures non-subagent calls pass through), dashboard section follows exact conventions (CSS classes, data-action attributes, collapsible pattern), persistence correctness (workspaceState serialization), disposable cleanup (no memory leaks).",
      "type": "validation",
      "status": "pending",
      "notes": "New files to review (7):\n1. session-types.ts (<80 lines)\n2. session-intercept-registry.ts (‚â§280 lines)\n3. tool-response-interceptor.ts (‚â§180 lines)\n4. sessions-section.ts (‚â§200 lines)\n5. session-interruption.instructions.md\n6. session-intercept-registry.test.ts\n7. tool-response-interceptor.test.ts\n\nModified files to review (~13):\n- spawn-agent-tool.ts, ToolProvider.ts, types.ts, extension.ts\n- DashboardViewProvider.ts, sections.ts, client-script.ts, dashboard-message-handlers.ts\n- event-emitter.ts (server), memory_agent.ts (server)\n- subagent-recovery.instructions.md, handoff-protocol.instructions.md\n- agent.md files (coordinator, executor, reviewer, tester)\n\nKey review areas:\n1. SessionInterceptRegistry persistence: Does persist() cover all mutations? Does restore() handle corrupt data?\n2. ToolProvider wrapInvoke: Is _session_id stripping safe (doesn't mutate shared objects)?\n3. Inject sanitization: Does it catch common prompt injection patterns?\n4. Dashboard section: Follows exact CSS/HTML conventions from existing sections?\n5. No file exceeds 300 lines?\n\nAcceptance: All review items addressed. No blocking issues. Approved for archival.",
      "assignee": "Reviewer",
      "index": 23
    }
  ],
  "recommended_next_agent": "Coordinator"
}