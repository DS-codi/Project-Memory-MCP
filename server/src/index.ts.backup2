/**
 * Project Memory MCP Server
 * 
 * A local Model Context Protocol server for managing multi-agent
 * software development workflows with isolated workspace and plan state.
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';

// Import tools
import * as workspaceTools from './tools/workspace.tools.js';
import * as planTools from './tools/plan.tools.js';
import * as handoffTools from './tools/handoff.tools.js';
import * as contextTools from './tools/context.tools.js';
import * as agentTools from './tools/agent.tools.js';
import * as validationTools from './tools/agent-validation.tools.js';
import * as store from './storage/file-store.js';
import { logToolCall, setCurrentAgent } from './logging/tool-logger.js';

// Import consolidated tools
import * as consolidatedTools from './tools/consolidated/index.js';

// =============================================================================
// Logging Helper
// =============================================================================

/**
 * Wrap a tool execution with logging
 */
async function withLogging<T>(
  toolName: string,
  params: Record<string, unknown>,
  fn: () => Promise<T>
): Promise<T> {
  const startTime = Date.now();
  
  try {
    const result = await fn();
    const durationMs = Date.now() - startTime;
    
    // Extract success/error from result if it has that shape
    const resultObj = result as { success?: boolean; error?: string };
    await logToolCall(
      toolName,
      params,
      resultObj.success !== false ? 'success' : 'error',
      resultObj.error,
      durationMs
    );
    
    return result;
  } catch (error) {
    const durationMs = Date.now() - startTime;
    await logToolCall(
      toolName,
      params,
      'error',
      (error as Error).message,
      durationMs
    );
    throw error;
  }
}

// =============================================================================
// Server Setup
// =============================================================================

const server = new McpServer({
  name: 'project-memory',
  version: '1.0.0'
});

// =============================================================================
// Tool Schemas
// =============================================================================

const AgentTypeSchema = z.enum([
  'Coordinator', 'Researcher', 'Architect', 'Executor', 
  'Revisionist', 'Reviewer', 'Tester', 'Archivist'
]);

const StepStatusSchema = z.enum(['pending', 'active', 'done', 'blocked']);

const PrioritySchema = z.enum(['low', 'medium', 'high', 'critical']);

const RequestCategorySchema = z.enum([
  'feature',       // Add new functionality
  'bug',           // Fix something broken
  'change',        // Modify existing behavior
  'analysis',      // Understand how something works
  'debug',         // Investigate a specific issue
  'refactor',      // Improve code without changing behavior
  'documentation'  // Update or create docs
]);

const RequestCategorizationSchema = z.object({
  category: RequestCategorySchema,
  confidence: z.number().min(0).max(1).describe('Confidence in categorization (0-1)'),
  reasoning: z.string().describe('Explanation of why this category was chosen'),
  suggested_workflow: z.array(AgentTypeSchema).describe('Suggested agent workflow for this request'),
  skip_agents: z.array(AgentTypeSchema).optional().describe('Agents that can be skipped for this request type')
});

// =============================================================================
// Workspace Tools
// =============================================================================

server.tool(
  'register_workspace',
  'Register a workspace directory. Creates a folder for the workspace if it does not exist. Returns workspace_id for use in other tools.',
  {
    workspace_path: z.string().describe('Absolute path to the workspace directory')
  },
  async (params) => {
    const result = await withLogging('register_workspace', params, () =>
      workspaceTools.registerWorkspace({
        workspace_path: params.workspace_path
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'list_workspaces',
  'List all registered workspaces with their metadata.',
  {},
  async (params) => {
    const result = await withLogging('list_workspaces', params, () =>
      workspaceTools.listWorkspaces()
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'get_workspace_plans',
  'Get all plans for a specific workspace.',
  {
    workspace_id: z.string().describe('The workspace ID returned from register_workspace')
  },
  async (params) => {
    const result = await withLogging('get_workspace_plans', params, () =>
      workspaceTools.getWorkspacePlans({
        workspace_id: params.workspace_id
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'reindex_workspace',
  'Re-index a workspace to update the codebase profile after significant changes. Use after successful reviews to capture new files, dependencies, or structural changes. Returns the previous and new profiles with a summary of changes.',
  {
    workspace_id: z.string().describe('The workspace ID to re-index')
  },
  async (params) => {
    const result = await withLogging('reindex_workspace', params, () =>
      workspaceTools.reindexWorkspace({
        workspace_id: params.workspace_id
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

// =============================================================================
// Plan Tools
// =============================================================================

server.tool(
  'find_plan',
  'Find a plan by just its ID (hash) - searches across all workspaces. Use this when you only have a plan_id and need to find the workspace_id. Returns full plan state and resume instructions.',
  {
    plan_id: z.string().describe('The plan ID (e.g., plan_ml0ops06_603c6237)')
  },
  async (params) => {
    const result = await withLogging('find_plan', params, () =>
      planTools.findPlan({
        plan_id: params.plan_id
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'list_plans',
  'List all plans for a workspace. Shows active plans with progress summary, current agent, and status. Use workspace_id or workspace_path.',
  {
    workspace_id: z.string().optional().describe('The workspace ID (from register_workspace)'),
    workspace_path: z.string().optional().describe('The absolute path to the workspace directory')
  },
  async (params) => {
    const result = await withLogging('list_plans', params, () =>
      planTools.listPlans({
        workspace_id: params.workspace_id,
        workspace_path: params.workspace_path
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'create_plan',
  'Create a new plan within a workspace. Requires categorizing the request type (feature, bug, change, analysis, debug, refactor, documentation). Returns the plan state with plan_id.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    title: z.string().describe('Title of the plan/feature'),
    description: z.string().describe('Detailed description of what needs to be done'),
    category: RequestCategorySchema.describe('Type of request: feature, bug, change, analysis, debug, refactor, or documentation'),
    priority: PrioritySchema.optional().describe('Priority level (low, medium, high, critical)'),
    categorization: RequestCategorizationSchema.optional().describe('Full categorization details including confidence and suggested workflow')
  },
  async (params) => {
    const result = await withLogging('create_plan', params, () =>
      planTools.createPlan({
        workspace_id: params.workspace_id,
        title: params.title,
        description: params.description,
        category: params.category,
        priority: params.priority,
        categorization: params.categorization
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'get_plan_state',
  'Get the complete current state of a plan including steps, lineage, and agent sessions.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID')
  },
  async (params) => {
    const result = await withLogging('get_plan_state', params, () =>
      planTools.getPlanState({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'update_step',
  'Update the status of a specific step in the plan.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    step_index: z.number().describe('Index of the step to update'),
    status: StepStatusSchema.describe('New status (pending, active, done, blocked)'),
    notes: z.string().optional().describe('Optional notes about the step')
  },
  async (params) => {
    const result = await withLogging('update_step', params, () =>
      planTools.updateStep({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        step_index: params.step_index,
        status: params.status,
        notes: params.notes
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'batch_update_steps',
  'Update multiple steps at once. Useful for marking several steps done or changing statuses in bulk.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    updates: z.array(z.object({
      step_index: z.number().describe('Index of the step to update'),
      status: StepStatusSchema.describe('New status (pending, active, done, blocked)'),
      notes: z.string().optional().describe('Optional notes about the step')
    })).describe('Array of step updates to apply')
  },
  async (params) => {
    const result = await withLogging('batch_update_steps', params, () =>
      planTools.batchUpdateSteps({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        updates: params.updates
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'modify_plan',
  'Replace ALL plan steps with a new set. WARNING: This replaces existing steps. Use append_steps to add steps to an existing plan. Has safeguards against accidental mass deletion.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    new_steps: z.array(z.object({
      phase: z.string().describe('Phase name (e.g., audit, research, implementation)'),
      task: z.string().describe('Description of the task'),
      status: StepStatusSchema.optional().describe('Initial status (defaults to pending)')
    })).describe('Array of new steps')
  },
  async (params) => {
    const result = await withLogging('modify_plan', params, () =>
      planTools.modifyPlan({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        new_steps: params.new_steps.map(s => ({
          phase: s.phase,
          task: s.task,
          status: s.status || 'pending' as const
        }))
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'append_steps',
  'Append new steps to an existing plan. Safer than modify_plan - preserves all existing steps and adds new ones at the end. Use this for adding new phases.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    new_steps: z.array(z.object({
      phase: z.string().describe('Phase name (e.g., phase-8-new-feature)'),
      task: z.string().describe('Description of the task'),
      status: StepStatusSchema.optional().describe('Initial status (defaults to pending)')
    })).describe('Array of steps to append')
  },
  async (params) => {
    const result = await withLogging('append_steps', params, () =>
      planTools.appendSteps({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        new_steps: params.new_steps.map(s => ({
          phase: s.phase,
          task: s.task,
          status: s.status || 'pending' as const
        }))
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'archive_plan',
  'Archive a completed plan. Moves it from active to archived status.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID')
  },
  async (params) => {
    const result = await withLogging('archive_plan', params, () =>
      planTools.archivePlan({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'add_plan_note',
  'Add a note to the plan that will be included in the next agent/tool response. Notes are auto-cleared after delivery with an audit log entry. Use this for user feedback, additional context, or instructions for the next agent.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    note: z.string().describe('The note content'),
    type: z.enum(['info', 'warning', 'instruction']).optional().describe('Note type (defaults to info)')
  },
  async (params) => {
    const result = await withLogging('add_plan_note', params, () =>
      planTools.addPlanNote({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        note: params.note,
        type: params.type
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'import_plan',
  'Import an existing plan file from the workspace into the MCP server. Copies the plan to the data directory, extracts steps from checkbox patterns, and moves the original file to an /archive folder in the workspace. Use this when pointed at a pre-existing plan document.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_file_path: z.string().describe('Absolute path to the plan file in the workspace (e.g., a .md file)'),
    title: z.string().optional().describe('Optional title override (otherwise extracted from first # heading or filename)'),
    category: RequestCategorySchema.describe('Type of request: feature, bug, change, analysis, debug, refactor, or documentation'),
    priority: PrioritySchema.optional().describe('Priority level (low, medium, high, critical)'),
    categorization: RequestCategorizationSchema.optional().describe('Full categorization details including confidence and suggested workflow')
  },
  async (params) => {
    const result = await withLogging('import_plan', params, () =>
      planTools.importPlan({
        workspace_id: params.workspace_id,
        plan_file_path: params.plan_file_path,
        title: params.title,
        category: params.category,
        priority: params.priority,
        categorization: params.categorization
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

// =============================================================================
// Agent Lifecycle Tools
// =============================================================================

server.tool(
  'initialise_agent',
  'REQUIRED: Must be called first by every agent. Records agent activation and returns full plan state for context. If workspace_id or plan_id are missing, returns status info to help the agent proceed (e.g., list of registered workspaces or active plans).',
  {
    workspace_id: z.string().optional().describe('The workspace ID (if not provided, returns workspace registration status)'),
    plan_id: z.string().optional().describe('The plan ID (if not provided, returns list of active plans)'),
    agent_type: AgentTypeSchema.describe('Type of agent being initialized'),
    context: z.record(z.unknown()).describe('Full context object specific to this agent type')
  },
  async (params) => {
    // Set current agent for logging purposes
    if (params.plan_id) {
      setCurrentAgent(params.plan_id, params.agent_type);
    }
    const result = await withLogging('initialise_agent', params, () =>
      handoffTools.initialiseAgent({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        agent_type: params.agent_type,
        context: params.context
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'complete_agent',
  'Mark an agent session as complete. Records summary and output artifacts.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    agent_type: AgentTypeSchema.describe('Type of agent completing'),
    summary: z.string().describe('Summary of what the agent accomplished'),
    artifacts: z.array(z.string()).optional().describe('List of artifact filenames created')
  },
  async (params) => {
    const result = await withLogging('complete_agent', params, () =>
      handoffTools.completeAgent({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        agent_type: params.agent_type,
        summary: params.summary,
        artifacts: params.artifacts
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'handoff',
  'Transfer control from one agent to another. Records the handoff in lineage.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    from_agent: AgentTypeSchema.describe('Agent handing off'),
    to_agent: AgentTypeSchema.describe('Agent receiving control'),
    reason: z.string().describe('Reason for the handoff'),
    data: z.record(z.unknown()).optional().describe('Optional data to pass to next agent')
  },
  async (params) => {
    // Update current agent tracking on handoff
    if (params.plan_id) {
      setCurrentAgent(params.plan_id, params.to_agent);
    }
    const result = await withLogging('handoff', params, () =>
      handoffTools.handoff({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        from_agent: params.from_agent,
        to_agent: params.to_agent,
        reason: params.reason,
        data: params.data
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'get_mission_briefing',
  'Get the mission briefing for a plan. Returns deployment context, previous sessions, and current steps.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID')
  },
  async (params) => {
    const result = await withLogging('get_mission_briefing', params, () =>
      handoffTools.getMissionBriefing({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'get_lineage',
  'Get the full handoff history for a plan.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID')
  },
  async (params) => {
    const result = await withLogging('get_lineage', params, () =>
      handoffTools.getLineage({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

// =============================================================================
// Context Tools
// =============================================================================

server.tool(
  'store_initial_context',
  'Store the initial user request and all associated context for a plan. Use this when creating a new plan to capture what the user wants. Only Researcher and Architect will read this.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    user_request: z.string().describe('The verbatim user request'),
    files_mentioned: z.array(z.string()).optional().describe('Files the user referenced'),
    file_contents: z.record(z.string()).optional().describe('Attached file contents (path -> content)'),
    requirements: z.array(z.string()).optional().describe('Explicit requirements from user'),
    constraints: z.array(z.string()).optional().describe('Constraints or limitations mentioned'),
    examples: z.array(z.string()).optional().describe('Examples or references provided'),
    conversation_context: z.string().optional().describe('Any prior conversation context'),
    additional_notes: z.string().optional().describe('Any other relevant notes')
  },
  async (params) => {
    const result = await withLogging('store_initial_context', params, () =>
      contextTools.storeInitialContext({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        user_request: params.user_request,
        files_mentioned: params.files_mentioned,
        file_contents: params.file_contents,
        requirements: params.requirements,
        constraints: params.constraints,
        examples: params.examples,
        conversation_context: params.conversation_context,
        additional_notes: params.additional_notes
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'store_context',
  'Store context data (audit findings, research results, decisions, etc.) as JSON.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    type: z.string().describe('Type of context (e.g., audit, research, decisions)'),
    data: z.record(z.unknown()).describe('The context data to store')
  },
  async (params) => {
    const result = await withLogging('store_context', params, () =>
      contextTools.storeContext({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        type: params.type,
        data: params.data
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'get_context',
  'Retrieve stored context data by type.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    type: z.string().describe('Type of context to retrieve')
  },
  async (params) => {
    const result = await withLogging('get_context', params, () =>
      contextTools.getContext({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        type: params.type
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'append_research',
  'Add a research note file to the plan.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    filename: z.string().describe('Name of the research file (e.g., oauth-flow.md)'),
    content: z.string().describe('Content of the research note')
  },
  async (params) => {
    const result = await withLogging('append_research', params, () =>
      contextTools.appendResearch({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        filename: params.filename,
        content: params.content
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'list_context',
  'List all context files for a plan.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID')
  },
  async (params) => {
    const result = await withLogging('list_context', params, () =>
      contextTools.listContext({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'list_research_notes',
  'List all research note files for a plan.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID')
  },
  async (params) => {
    const result = await withLogging('list_research_notes', params, () =>
      contextTools.listResearchNotes({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'generate_plan_instructions',
  'Generate a dynamic .instructions.md file with current plan context. Optionally writes to a file path for Copilot to discover.',
  {
    workspace_id: z.string().describe('The workspace ID'),
    plan_id: z.string().describe('The plan ID'),
    output_path: z.string().optional().describe('Optional path to write the instructions file (e.g., .github/instructions/current-plan.instructions.md)')
  },
  async (params) => {
    const result = await withLogging('generate_plan_instructions', params, () =>
      contextTools.generatePlanInstructions({
        workspace_id: params.workspace_id,
        plan_id: params.plan_id,
        output_path: params.output_path
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

// =============================================================================
// Agent Deployment Tools
// =============================================================================

server.tool(
  'list_agents',
  'List all available agent instruction files that can be deployed to workspaces.',
  {},
  async (params) => {
    const result = await withLogging('list_agents', params, () =>
      agentTools.listAgents()
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'deploy_agents_to_workspace',
  'Copy agent instruction files (.agent.md), prompt files (.prompt.md), and instruction files (.instructions.md) to a workspace\'s .github/ directory for VS Code Copilot to discover.',
  {
    workspace_path: z.string().describe('Absolute path to the target workspace'),
    agents: z.array(z.string()).optional().describe('Optional list of specific agents to deploy (e.g., ["auditor", "executor"]). Deploys all if omitted.'),
    include_prompts: z.boolean().optional().describe('Whether to deploy prompt files. Defaults to true.'),
    include_instructions: z.boolean().optional().describe('Whether to deploy instruction files. Defaults to true.')
  },
  async (params) => {
    const result = await withLogging('deploy_agents_to_workspace', params, () =>
      agentTools.deployAgentsToWorkspace({
        workspace_path: params.workspace_path,
        agents: params.agents,
        include_prompts: params.include_prompts,
        include_instructions: params.include_instructions
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'get_agent_instructions',
  'Get the content of a specific agent instruction file.',
  {
    agent_name: z.string().describe('Name of the agent (e.g., "auditor", "executor")')
  },
  async (params) => {
    const result = await withLogging('get_agent_instructions', params, () =>
      agentTools.getAgentInstructions({
        agent_name: params.agent_name
      })
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

// =============================================================================
// Agent Validation Tools - MUST be called after initialise_agent
// =============================================================================

const ValidationParamsSchema = {
  workspace_id: z.string().describe('The workspace ID'),
  plan_id: z.string().describe('The plan ID')
};

server.tool(
  'validate_coordinator',
  'REQUIRED after initialise_agent for Coordinator. Validates this is the correct agent and returns role boundaries. If wrong agent, returns switch instruction.',
  ValidationParamsSchema,
  async (params) => {
    const result = await withLogging('validate_coordinator', params, () =>
      validationTools.validateCoordinator(params)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'validate_researcher',
  'REQUIRED after initialise_agent for Researcher. Validates this is the correct agent and returns role boundaries. If wrong agent, returns switch instruction.',
  ValidationParamsSchema,
  async (params) => {
    const result = await withLogging('validate_researcher', params, () =>
      validationTools.validateResearcher(params)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'validate_architect',
  'REQUIRED after initialise_agent for Architect. Validates this is the correct agent and returns role boundaries. If wrong agent, returns switch instruction.',
  ValidationParamsSchema,
  async (params) => {
    const result = await withLogging('validate_architect', params, () =>
      validationTools.validateArchitect(params)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'validate_executor',
  'REQUIRED after initialise_agent for Executor. Validates this is the correct agent and returns role boundaries. If wrong agent, returns switch instruction.',
  ValidationParamsSchema,
  async (params) => {
    const result = await withLogging('validate_executor', params, () =>
      validationTools.validateExecutor(params)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'validate_reviewer',
  'REQUIRED after initialise_agent for Reviewer. Validates this is the correct agent and returns role boundaries. If wrong agent, returns switch instruction.',
  ValidationParamsSchema,
  async (params) => {
    const result = await withLogging('validate_reviewer', params, () =>
      validationTools.validateReviewer(params)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'validate_tester',
  'REQUIRED after initialise_agent for Tester. Validates this is the correct agent and returns role boundaries. If wrong agent, returns switch instruction.',
  ValidationParamsSchema,
  async (params) => {
    const result = await withLogging('validate_tester', params, () =>
      validationTools.validateTester(params)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'validate_revisionist',
  'REQUIRED after initialise_agent for Revisionist. Validates this is the correct agent and returns role boundaries. If wrong agent, returns switch instruction.',
  ValidationParamsSchema,
  async (params) => {
    const result = await withLogging('validate_revisionist', params, () =>
      validationTools.validateRevisionist(params)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'validate_archivist',
  'REQUIRED after initialise_agent for Archivist. Validates this is the correct agent and returns role boundaries. If wrong agent, returns switch instruction.',
  ValidationParamsSchema,
  async (params) => {
    const result = await withLogging('validate_archivist', params, () =>
      validationTools.validateArchivist(params)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'validate_analyst',
  'REQUIRED after initialise_agent for Analyst. Validates this is the correct agent and returns role boundaries. If wrong agent, returns switch instruction.',
  ValidationParamsSchema,
  async (params) => {
    const result = await withLogging('validate_analyst', params, () =>
      validationTools.validateAnalyst(params)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

// =============================================================================
// CONSOLIDATED TOOLS (v2) - 5 tools replacing 39 individual tools
// These tools are ADDED alongside existing tools for verification
// Old tools will be removed only after testing confirms all actions work
// =============================================================================

server.tool(
  'memory_workspace',
  'Consolidated workspace management tool. Actions: register (register a workspace directory), list (list all workspaces), info (get plans for a workspace), reindex (update codebase profile after changes).',
  {
    action: z.enum(['register', 'list', 'info', 'reindex']).describe('The action to perform'),
    workspace_id: z.string().optional().describe('Workspace ID (for info, reindex)'),
    workspace_path: z.string().optional().describe('Workspace path (for register)')
  },
  async (params) => {
    const result = await withLogging('memory_workspace', params, () =>
      consolidatedTools.memoryWorkspace(params as consolidatedTools.MemoryWorkspaceParams)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'memory_plan',
  'Consolidated plan lifecycle management. Actions: list (list plans), get (get plan state), create (create new plan), update (modify plan steps), archive (archive completed plan), import (import existing plan file), find (find plan by ID), add_note (add note to plan).',
  {
    action: z.enum(['list', 'get', 'create', 'update', 'archive', 'import', 'find', 'add_note']).describe('The action to perform'),
    workspace_id: z.string().optional().describe('Workspace ID'),
    workspace_path: z.string().optional().describe('Workspace path (alternative to workspace_id for list)'),
    plan_id: z.string().optional().describe('Plan ID'),
    title: z.string().optional().describe('Plan title (for create/import)'),
    description: z.string().optional().describe('Plan description (for create)'),
    category: RequestCategorySchema.optional().describe('Request category'),
    priority: PrioritySchema.optional().describe('Priority level'),
    steps: z.array(z.object({
      phase: z.string(),
      task: z.string(),
      status: StepStatusSchema.optional().default('pending'),
      notes: z.string().optional(),
      assignee: z.string().optional()
    })).optional().describe('Plan steps (for update)'),
    include_archived: z.boolean().optional().describe('Include archived plans (for list)'),
    plan_file_path: z.string().optional().describe('Path to plan file (for import)'),
    note: z.string().optional().describe('Note content (for add_note)'),
    note_type: z.enum(['info', 'warning', 'instruction']).optional().describe('Note type'),
    categorization: RequestCategorizationSchema.optional().describe('Full categorization details')
  },
  async (params) => {
    const result = await withLogging('memory_plan', params, () =>
      consolidatedTools.memoryPlan(params as consolidatedTools.MemoryPlanParams)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'memory_steps',
  'Consolidated step management tool. Actions: add (append new steps), update (update single step status), batch_update (update multiple steps at once).',
  {
    action: z.enum(['add', 'update', 'batch_update']).describe('The action to perform'),
    workspace_id: z.string().describe('Workspace ID'),
    plan_id: z.string().describe('Plan ID'),
    steps: z.array(z.object({
      phase: z.string(),
      task: z.string(),
      status: StepStatusSchema.optional().default('pending'),
      notes: z.string().optional(),
      assignee: z.string().optional()
    })).optional().describe('Steps to add (for add action)'),
    step_index: z.number().optional().describe('Step index to update (for update action)'),
    status: StepStatusSchema.optional().describe('New status (for update action)'),
    notes: z.string().optional().describe('Notes to add (for update action)'),
    agent_type: z.string().optional().describe('Agent type making the update'),
    updates: z.array(z.object({
      index: z.number(),
      status: StepStatusSchema.optional(),
      notes: z.string().optional()
    })).optional().describe('Batch updates (for batch_update action)')
  },
  async (params) => {
    const result = await withLogging('memory_steps', params, () =>
      consolidatedTools.memorySteps(params as consolidatedTools.MemoryStepsParams)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'memory_agent',
  'Consolidated agent lifecycle and deployment tool. Actions: init (initialize agent session), complete (complete session), handoff (recommend next agent), validate (validate agent for current task), list (list available agents), get_instructions (get agent instructions), deploy (deploy agents to workspace), get_briefing (get mission briefing), get_lineage (get handoff history).',
  {
    action: z.enum(['init', 'complete', 'handoff', 'validate', 'list', 'get_instructions', 'deploy', 'get_briefing', 'get_lineage']).describe('The action to perform'),
    workspace_id: z.string().optional().describe('Workspace ID'),
    plan_id: z.string().optional().describe('Plan ID'),
    agent_type: AgentTypeSchema.optional().describe('Agent type'),
    context: z.record(z.unknown()).optional().describe('Context data (for init)'),
    summary: z.string().optional().describe('Session summary (for complete)'),
    artifacts: z.array(z.string()).optional().describe('Created artifacts (for complete)'),
    from_agent: AgentTypeSchema.optional().describe('Source agent (for handoff)'),
    to_agent: AgentTypeSchema.optional().describe('Target agent (for handoff)'),
    reason: z.string().optional().describe('Handoff reason'),
    data: z.record(z.unknown()).optional().describe('Handoff data'),
    agent_name: z.string().optional().describe('Agent name (for get_instructions)'),
    workspace_path: z.string().optional().describe('Workspace path (for deploy)'),
    agents: z.array(z.string()).optional().describe('Specific agents to deploy'),
    include_prompts: z.boolean().optional().describe('Include prompts in deployment'),
    include_instructions: z.boolean().optional().describe('Include instructions in deployment')
  },
  async (params) => {
    const result = await withLogging('memory_agent', params, () =>
      consolidatedTools.memoryAgent(params as consolidatedTools.MemoryAgentParams)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

server.tool(
  'memory_context',
  'Consolidated context and research management tool. Actions: store (store context data), get (retrieve context), store_initial (store initial user request), list (list context files), list_research (list research notes), append_research (add research note), generate_instructions (generate plan instructions file).',
  {
    action: z.enum(['store', 'get', 'store_initial', 'list', 'list_research', 'append_research', 'generate_instructions']).describe('The action to perform'),
    workspace_id: z.string().describe('Workspace ID'),
    plan_id: z.string().describe('Plan ID'),
    type: z.string().optional().describe('Context type (for store/get)'),
    data: z.record(z.unknown()).optional().describe('Context data (for store)'),
    user_request: z.string().optional().describe('User request text (for store_initial)'),
    files_mentioned: z.array(z.string()).optional().describe('Files mentioned by user'),
    file_contents: z.record(z.string()).optional().describe('File contents'),
    requirements: z.array(z.string()).optional().describe('Requirements'),
    constraints: z.array(z.string()).optional().describe('Constraints'),
    examples: z.array(z.string()).optional().describe('Examples'),
    conversation_context: z.string().optional().describe('Conversation context'),
    additional_notes: z.string().optional().describe('Additional notes'),
    filename: z.string().optional().describe('Research filename (for append_research)'),
    content: z.string().optional().describe('Research content (for append_research)'),
    output_path: z.string().optional().describe('Output path (for generate_instructions)')
  },
  async (params) => {
    const result = await withLogging('memory_context', params, () =>
      consolidatedTools.memoryContext(params as consolidatedTools.MemoryContextParams)
    );
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }
);

// =============================================================================
// Server Startup
// =============================================================================

async function main() {
  // Initialize data root
  await store.initDataRoot();
  
  console.error('Project Memory MCP Server starting...');
  console.error(`Data root: ${store.getDataRoot()}`);
  
  const transport = new StdioServerTransport();
  await server.connect(transport);
  
  console.error('Project Memory MCP Server running');
}

main().catch((error) => {
  console.error('Failed to start server:', error);
  process.exit(1);
});
